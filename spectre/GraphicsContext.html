        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>GraphicsContext class / spectre Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="spectre" data-type="GraphicsContext">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../spectre.html">spectre</a> &rsaquo; <a href="../spectre/GraphicsContext.html">GraphicsContext</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>GraphicsContext</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>The <a class="crossref" href="../spectre/GraphicsContext.html#GraphicsContext">GraphicsContext</a> configures the GPU pipeline and executes draw commands.</p>
<pre class="source">
class GraphicsContext {
 static final int numVertexBuffers = 2;
 static final int numTextures = 3;
 final GraphicsDevice device;

 // Input Assembler
 int _primitiveTopology;
 IndexBuffer _indexBufferHandle;
 List&lt;VertexBuffer&gt; _vertexBufferHandles;
 List&lt;int&gt; _enabledVertexAttributeArrays;
 InputLayout _inputLayoutHandle;
 InputLayout _preparedInputLayoutHandle;
 // VS and PS stages
 ShaderProgram _shaderProgramHandle;
 List&lt;SamplerState&gt; _samplerStateHandles;
 List&lt;SpectreTexture&gt; _textureHandles;
 StencilState _stencilStateHandle;
 RenderTarget _renderTargetHandle;

 //---------------------------------------------------------------------
 // Default variables
 //---------------------------------------------------------------------

 /// The default [BlendState] to use.
 /// Constructed with the values in [BlendState.opaque].
 BlendState _blendStateDefault;
 /// The default [DepthState] to use.
 /// Constructed with the values in [DepthState.depthWrite].
 DepthState _depthStateDefault;
 /// The default [RasterizerState] to use.
 /// Constructed with the values in [RasterizerState.cullClockwise].
 RasterizerState _rasterizerStateDefault;

 //---------------------------------------------------------------------
 // State variables
 //---------------------------------------------------------------------

 /// The current [Viewport] of the pipeline.
 Viewport _viewport;
 /// The current [BlendState] of the pipeline.
 BlendState _blendState;
 /// The current [DepthState] of the pipeline.
 DepthState _depthState;
 /// The current [RasterizerState] of the pipeline.
 RasterizerState _rasterizerState;

 //---------------------------------------------------------------------
 // Construction
 //---------------------------------------------------------------------

 GraphicsContext(this.device) {
   _vertexBufferHandles = new List&lt;VertexBuffer&gt;(numVertexBuffers);
   _samplerStateHandles = new List&lt;SamplerState&gt;(numTextures);
   _textureHandles = new List&lt;SpectreTexture&gt;(numTextures);
   _enabledVertexAttributeArrays = new List&lt;int&gt;();

   _initializeState();
   reset();
 }

 /// Initialize the WebGL pipeline state.
 /// Creates all the default state values and applies them to the pipeline.
 void _initializeState() {
   // Viewport setup
   _viewport = new Viewport('ViewportDefault', device);

   device.gl.viewport(_viewport.x, _viewport.y, _viewport.width, _viewport.height);
   device.gl.depthRange(_viewport.minDepth, _viewport.maxDepth);

   // BlendState setup
   _blendStateDefault = new BlendState.opaque('BlendStateDefault', device);
   _blendState = new BlendState.opaque('CurrentBlendState', device);

   device.gl.disable(WebGL.BLEND);
   device.gl.blendFuncSeparate(
     _blendState.colorSourceBlend,
     _blendState.colorDestinationBlend,
     _blendState.alphaSourceBlend,
     _blendState.alphaDestinationBlend
   );
   device.gl.blendEquationSeparate(_blendState.colorBlendOperation, _blendState.alphaBlendOperation);
   device.gl.colorMask(
     _blendState.writeRenderTargetRed,
     _blendState.writeRenderTargetGreen,
     _blendState.writeRenderTargetBlue,
     _blendState.writeRenderTargetAlpha
   );
   device.gl.blendColor(
     _blendState.blendFactorRed,
     _blendState.blendFactorGreen,
     _blendState.blendFactorBlue,
     _blendState.blendFactorAlpha
   );

   // DepthState setup
   _depthStateDefault = new DepthState.depthWrite('DepthStateDefault', device);
   _depthState = new DepthState.depthWrite('CurrentDepthState', device);

   device.gl.enable(WebGL.DEPTH_TEST);
   device.gl.depthMask(_depthState.depthBufferWriteEnabled);
   device.gl.depthFunc(_depthState.depthBufferFunction);

   // RasterizerState setup
   _rasterizerStateDefault = new RasterizerState.cullClockwise('RasterizerStateDefault', device);
   _rasterizerState = new RasterizerState.cullClockwise('CurrentRasterizerState', device);

   device.gl.enable(WebGL.CULL_FACE);
   device.gl.cullFace(_rasterizerState.cullMode);
   device.gl.frontFace(_rasterizerState.frontFace);

   device.gl.disable(WebGL.POLYGON_OFFSET_FILL);
   device.gl.polygonOffset(_rasterizerState.depthBias, _rasterizerState.slopeScaleDepthBias);

   device.gl.disable(WebGL.SCISSOR_TEST);
 }

 void _prepareInputs({bool debug: false}) {
   if (_inputLayoutHandle == 0) {
     spectreLog.Error('Prepare for draw no input layout');
     return;
   }

   InputLayout inputLayout = _inputLayoutHandle;
   if (inputLayout == null) {
     spectreLog.Error('Prepare for draw no input layout.');
     return;
   }

   if (_preparedInputLayoutHandle == _inputLayoutHandle) {
     return;
   }

   _preparedInputLayoutHandle = _inputLayoutHandle;

   // Disable old arrays
   for (int index in _enabledVertexAttributeArrays) {
     if (index == 0) {
       continue;
     }
     device.gl.disableVertexAttribArray(index);
   }
   _enabledVertexAttributeArrays.clear();

   inputLayout.attributes.forEach((element) {
     VertexBuffer vb = _vertexBufferHandles[element.vboSlot];
     if (vb == null) {
       spectreLog.Error('Prepare for draw referenced a null vertex buffer object');
       return;
     }
     device.gl.enableVertexAttribArray(element.attributeIndex);
     vb._bind();
     device.gl.vertexAttribPointer(element.attributeIndex,
       element.dataCount,
       element.dataType,
       element.normalizeData,
       element.attributeStride,
       element.attributeOffset);
     // Remember that this was enabled.
     _enabledVertexAttributeArrays.add(element.attributeIndex);
   });
   if (_indexBufferHandle != null) {
     IndexBuffer indexBuffer = _indexBufferHandle;
     indexBuffer._bind();
   } else {
     device.gl.bindBuffer(WebGL.ELEMENT_ARRAY_BUFFER, null);
   }
 }

 void _prepareTextures() {
   // TODO: Need to unbind unused texture channels
   for (int i = 0; i &lt; numTextures; i++) {
     SamplerState sampler = _samplerStateHandles[i];
     SpectreTexture texture = _textureHandles[i];
     device.gl.activeTexture(WebGL.TEXTURE0 + i);
     device.gl.bindTexture(WebGL.TEXTURE_2D, null);
     device.gl.bindTexture(WebGL.TEXTURE_CUBE_MAP, null);
     if (sampler == null || texture == null) {
       continue;
     }
     texture._bind(WebGL.TEXTURE0 + i);
     texture._applySampler(sampler);
   }
 }


 /// Resets the cached GPU pipeline state
 void reset() {
   // TODO: Update GPU state
   _primitiveTopology = 0;
   for (int index in _enabledVertexAttributeArrays) {
     if (index == 0) {
       continue;
     }
     device.gl.disableVertexAttribArray(index);
   }
   _preparedInputLayoutHandle = null;
   _enabledVertexAttributeArrays.clear();
   _indexBufferHandle = null;
   for (int i = 0; i &lt; numVertexBuffers; i++) {
     _vertexBufferHandles[i] = null;
   }
   _inputLayoutHandle = null;
   _shaderProgramHandle = null;
   for (int i = 0; i &lt; numTextures; i++) {
     _samplerStateHandles[i] = null;
     _textureHandles[i] = null;
   }
   _stencilStateHandle = null;
   _renderTargetHandle = null;

   setBlendState(_blendStateDefault);
   setDepthState(_depthStateDefault);
   setRasterizerState(_rasterizerStateDefault);
 }

 /// Configure the primitive topology
 void setPrimitiveTopology(int topology) {
   _primitiveTopology = topology;
 }

 /// Set the IndexBuffer to [indexBufferHandle]
 void setIndexBuffer(IndexBuffer indexBufferHandle) {
   _indexBufferHandle = indexBufferHandle;
 }

 /// Set multiple VertexBuffers in [vertexBufferHandles] starting at [startSlot]
 void setVertexBuffers(int startSlot, List&lt;VertexBuffer&gt; vertexBufferHandles) {
   int limit = vertexBufferHandles.length + startSlot;
   for (int i = startSlot; i &lt; limit; i++) {
     _vertexBufferHandles[i] = vertexBufferHandles[i-startSlot];
   }
 }

 /// Set InputLayout to [inputLayoutHandle]
 void setInputLayout(InputLayout inputLayoutHandle) {
   _inputLayoutHandle = inputLayoutHandle;
 }

 void setIndexedMesh(SingleArrayIndexedMesh indexedMesh) {
   if (indexedMesh == null) {
     return;
   }
   setPrimitiveTopology(indexedMesh.primitiveTopology);
   setIndexBuffer(indexedMesh.indexArray);
   setVertexBuffers(0, [indexedMesh.vertexArray]);
 }

 void setMesh(SingleArrayMesh mesh) {
   if (mesh == null) {
     return;
   }
   setPrimitiveTopology(mesh.primitiveTopology);
   setIndexBuffer(null);
   setVertexBuffers(0, [mesh.vertexArray]);
 }

 /// Set ShaderProgram to [shaderProgramHandle]
 void setShaderProgram(ShaderProgram shaderProgramHandle) {
   if (_shaderProgramHandle == shaderProgramHandle) {
     return;
   }
   _shaderProgramHandle = shaderProgramHandle;
   ShaderProgram sp = shaderProgramHandle;
   device.gl.useProgram(sp._program);
 }

 /// Sets a [Viewport] identifying the portion of the render target to receive draw calls.
 void setViewport(Viewport viewport) {
   if (viewport == null) {
     return;
   }

   if ((_viewport.x      != viewport.x)     ||
       (_viewport.y      != viewport.y)     ||
       (_viewport.width  != viewport.width) ||
       (_viewport.height != viewport.height))
   {
     device.gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

     _viewport.x      = viewport.x;
     _viewport.y      = viewport.y;
     _viewport.width  = viewport.width;
     _viewport.height = viewport.height;
   }

   if ((_viewport.minDepth != viewport.minDepth) || (_viewport.maxDepth != viewport.maxDepth)) {
     device.gl.depthRange(viewport.minDepth, viewport.maxDepth);

     _viewport.minDepth = viewport.minDepth;
     _viewport.maxDepth = viewport.maxDepth;
   }
 }

 /// Sets the current [BlendState] to use on the pipeline.
 ///
 /// If [blendState] is null all values of the pipeline associated with blending
 /// will be reset to their defaults.
 void setBlendState(BlendState blendState) {
   if (blendState == null) {
     setBlendState(_blendStateDefault);
     return;
   }

   // Disable/Enable blending if necessary
   if (_blendState.enabled != blendState.enabled) {
     if (blendState.enabled) {
       device.gl.enable(WebGL.BLEND);
     } else {
       device.gl.disable(WebGL.BLEND);
     }

     _blendState.enabled = blendState.enabled;
   }

   // Modify the color write channels if necessary
   if ((_blendState.writeRenderTargetRed   != blendState.writeRenderTargetRed)   ||
       (_blendState.writeRenderTargetGreen != blendState.writeRenderTargetGreen) ||
       (_blendState.writeRenderTargetBlue  != blendState.writeRenderTargetBlue)  ||
       (_blendState.writeRenderTargetAlpha != blendState.writeRenderTargetAlpha))
   {
     device.gl.colorMask(
       blendState.writeRenderTargetRed,
       blendState.writeRenderTargetGreen,
       blendState.writeRenderTargetBlue,
       blendState.writeRenderTargetAlpha
     );

     _blendState.writeRenderTargetRed   = blendState.writeRenderTargetRed;
     _blendState.writeRenderTargetGreen = blendState.writeRenderTargetGreen;
     _blendState.writeRenderTargetBlue  = blendState.writeRenderTargetBlue;
     _blendState.writeRenderTargetAlpha = blendState.writeRenderTargetAlpha;
   }

   // If blending is enabled enable all the functionality
   if (_blendState.enabled) {
     // Modify the blend functions if necessary
     if ((_blendState.colorSourceBlend      != blendState.colorSourceBlend)      ||
         (_blendState.colorDestinationBlend != blendState.colorDestinationBlend) ||
         (_blendState.alphaSourceBlend      != blendState.alphaSourceBlend)      ||
         (_blendState.alphaDestinationBlend != blendState.alphaDestinationBlend))
     {
       device.gl.blendFuncSeparate(
         blendState.colorSourceBlend,
         blendState.colorDestinationBlend,
         blendState.alphaSourceBlend,
         blendState.alphaDestinationBlend
       );

       _blendState.colorSourceBlend      = blendState.colorSourceBlend;
       _blendState.colorDestinationBlend = blendState.colorDestinationBlend;
       _blendState.alphaSourceBlend      = blendState.alphaSourceBlend;
       _blendState.alphaDestinationBlend = blendState.alphaDestinationBlend;
     }

     // Modify the blend operations if necessary
     if ((_blendState.colorBlendOperation != blendState.colorBlendOperation) ||
         (_blendState.alphaBlendOperation != blendState.alphaBlendOperation))
     {
       device.gl.blendEquationSeparate(blendState.colorBlendOperation, blendState.alphaBlendOperation);

       _blendState.colorBlendOperation = blendState.colorBlendOperation;
       _blendState.alphaBlendOperation = blendState.alphaBlendOperation;
     }

     // Modify the blend factor if necessary
     if ((_blendState.blendFactorRed   != blendState.blendFactorRed)   ||
         (_blendState.blendFactorGreen != blendState.blendFactorGreen) ||
         (_blendState.blendFactorBlue  != blendState.blendFactorBlue)  ||
         (_blendState.blendFactorAlpha != blendState.blendFactorAlpha))
     {
       device.gl.blendColor(
         blendState.blendFactorRed,
         blendState.blendFactorGreen,
         blendState.blendFactorBlue,
         blendState.blendFactorAlpha
       );

       _blendState.blendFactorRed   = blendState.blendFactorRed;
       _blendState.blendFactorGreen = blendState.blendFactorGreen;
       _blendState.blendFactorBlue  = blendState.blendFactorBlue;
       _blendState.blendFactorAlpha = blendState.blendFactorAlpha;
     }
   }
 }

 /// Sets the current [DepthState] to use on the pipeline.
 ///
 /// If [depthState] is null all values of the pipeline associated with depth
 /// will be reset to their defaults.
 void setDepthState(DepthState depthState) {
   if (depthState == null) {
     return;
   }

   if (_depthState.depthBufferEnabled != depthState.depthBufferEnabled) {
     if (depthState.depthBufferEnabled) {
       device.gl.enable(WebGL.DEPTH_TEST);
     } else {
       device.gl.disable(WebGL.DEPTH_TEST);
     }

     _depthState.depthBufferEnabled = depthState.depthBufferEnabled;
   }

   if ((_depthState.depthBufferEnabled) &amp;&amp; (_depthState.depthBufferFunction != depthState.depthBufferFunction)) {
     device.gl.depthFunc(depthState.depthBufferFunction);

     _depthState.depthBufferFunction = depthState.depthBufferFunction;
   }

   if (_depthState.depthBufferWriteEnabled != depthState.depthBufferWriteEnabled) {
     device.gl.depthMask(depthState.depthBufferWriteEnabled);

     _depthState.depthBufferWriteEnabled = depthState.depthBufferWriteEnabled;
   }
 }

 /// Sets the current [RasterizerState] to use on the pipeline.
 ///
 /// If [rasterizerState] is null all values of the pipeline associated with rasterization
 /// will be reset to their defaults.
 void setRasterizerState(RasterizerState rasterizerState) {
   if (rasterizerState == null) {
     setRasterizerState(_rasterizerStateDefault);
     return;
   }

   // Disable/Enable culling if necessary
   if (_rasterizerState.cullMode != rasterizerState.cullMode) {
     if (rasterizerState.cullMode == CullMode.None) {
       device.gl.disable(WebGL.CULL_FACE);

       _rasterizerState.cullMode = rasterizerState.cullMode;
     } else if (_rasterizerState.cullMode == CullMode.None) {
       device.gl.enable(WebGL.CULL_FACE);
     }
   }

   // If culling is enabled enable culling mode and winding order
   if (rasterizerState.cullMode != CullMode.None) {
     // Modify the cull mode if necessary
     if (_rasterizerState.cullMode != rasterizerState.cullMode) {
       device.gl.cullFace(rasterizerState.cullMode);

       _rasterizerState.cullMode = rasterizerState.cullMode;
     }

     // Modify the front face if necessary
     if (_rasterizerState.frontFace != rasterizerState.frontFace) {
       device.gl.frontFace(rasterizerState.frontFace);

       _rasterizerState.frontFace = rasterizerState.frontFace;
     }
   }

   bool offsetEnabled = ((_rasterizerState.depthBias != 0.0) || (_rasterizerState.slopeScaleDepthBias != 0.0));

   if ((rasterizerState.depthBias != 0.0) || (rasterizerState.slopeScaleDepthBias != 0)) {
     // Enable polygon offset
     if (!offsetEnabled) {
       device.gl.enable(WebGL.POLYGON_OFFSET_FILL);
     }

     // Modify the polygon offset if necessary
     if ((_rasterizerState.depthBias           != rasterizerState.depthBias) ||
         (_rasterizerState.slopeScaleDepthBias != rasterizerState.slopeScaleDepthBias))
     {
       device.gl.polygonOffset(rasterizerState.depthBias, rasterizerState.slopeScaleDepthBias);

       _rasterizerState.depthBias           = rasterizerState.depthBias;
       _rasterizerState.slopeScaleDepthBias = rasterizerState.slopeScaleDepthBias;
     }
   } else {
     // Disable polygon offset
     if (offsetEnabled) {
       device.gl.disable(WebGL.POLYGON_OFFSET_FILL);

       _rasterizerState.depthBias           = rasterizerState.depthBias;
       _rasterizerState.slopeScaleDepthBias = rasterizerState.slopeScaleDepthBias;
     }
   }

   // Disable/Enable scissor test if necessary
   if (_rasterizerState.scissorTestEnabled != rasterizerState.scissorTestEnabled) {
     if (rasterizerState.scissorTestEnabled) {
       device.gl.enable(WebGL.SCISSOR_TEST);
     } else {
       device.gl.disable(WebGL.SCISSOR_TEST);
     }

     _rasterizerState.scissorTestEnabled = rasterizerState.scissorTestEnabled;
   }
 }

 /// Set RenderTarget to [renderTargetHandle]
 void setRenderTarget(RenderTarget renderTargetHandle) {
   _renderTargetHandle = renderTargetHandle;
   _renderTargetHandle._bind();
 }

 ShaderProgramUniform _findUniform(String name) {
   ShaderProgram sp = _shaderProgramHandle;
   if (sp == null) {
     return null;
   }
   return sp.uniforms[name];
 }

 void setConstant(String name, var argument) {
   ShaderProgramUniform uniform = _findUniform(name);
   if (uniform != null) {
     uniform._apply(device, uniform.location, argument);
   } else if (_shaderProgramHandle == null ){
     spectreLog.Error('Cannot set $name: no ShaderProgram bound.');
   } else {
     //spectreLog.Error('Cannot set $name: not found.');
   }
 }

 void clearColorBuffer(num r, num g, num b, num a) {
   device.gl.clearColor(r, g, b, a);
   device.gl.clear(WebGL.COLOR_BUFFER_BIT);
 }

 void clearDepthBuffer(num depth) {
   device.gl.clearDepth(depth);
   device.gl.clear(WebGL.DEPTH_BUFFER_BIT);
 }

 void clearStencilBuffer(int stencil) {
   device.gl.clearStencil(stencil);
   device.gl.clear(WebGL.STENCIL_BUFFER_BIT);
 }

 /// Sets a list of [textureHandles] starting at [texUnitOffset]
 void setTextures(int texUnitOffset, List&lt;SpectreTexture&gt; textureHandles) {
   for (int i = texUnitOffset; i &lt; textureHandles.length; i++) {
     _textureHandles[i] = textureHandles[i-texUnitOffset];
   }
 }

 /// Sets a list of [samplerHandles] starting at [texUnitOffset]
 void setSamplers(int texUnitOffset, List&lt;SamplerState&gt; samplerHandles) {
   for (int i = texUnitOffset; i &lt; samplerHandles.length; i++) {
     _samplerStateHandles[i] = samplerHandles[i-texUnitOffset];
   }
 }

 /// Draw an indexed mesh with [numIndices] starting at [indexOffset]
 void drawIndexed(int numIndices, int indexOffset) {
   if (numIndices == 0) {
     return;
   }
   _prepareInputs();
   _prepareTextures();
   device.gl.drawElements(_primitiveTopology, numIndices,
                          WebGL.UNSIGNED_SHORT, indexOffset);
 }

 void drawIndexedMesh(SingleArrayIndexedMesh indexedMesh) {
   if (indexedMesh == null) {
     return;
   }
   drawIndexed(indexedMesh.count, 0);
 }

 void drawMesh(SingleArrayMesh mesh) {
   if (mesh == null) {
     return;
   }
   draw(mesh.count, 0);
 }

 /// Draw a mesh with [numVertices] starting at [vertexOffset]
 void draw(int numVertices, int vertexOffset) {
   if (numVertices == 0) {
     return;
   }
   _prepareInputs();
   _prepareTextures();
   device.gl.drawArrays(_primitiveTopology, vertexOffset, numVertices);
 }
}
</pre>
</div>
<div>
<h3>Static Properties</h3>
<div class="field"><h4 id="numTextures">
<button class="show-code">Code</button>
final int         <strong>numTextures</strong> <a class="anchor-link"
            href="#numTextures"
            title="Permalink to GraphicsContext.numTextures">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static final int numTextures = 3
</pre>
</div>
</div>
<div class="field"><h4 id="numVertexBuffers">
<button class="show-code">Code</button>
final int         <strong>numVertexBuffers</strong> <a class="anchor-link"
            href="#numVertexBuffers"
            title="Permalink to GraphicsContext.numVertexBuffers">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static final int numVertexBuffers = 2
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="GraphicsContext">
<button class="show-code">Code</button>
new <strong>GraphicsContext</strong>(<a href="../spectre/GraphicsDevice.html">GraphicsDevice</a> device) <a class="anchor-link" href="#GraphicsContext"
              title="Permalink to GraphicsContext.GraphicsContext">#</a></h4>
<div class="doc">
<pre class="source">
GraphicsContext(this.device) {
 _vertexBufferHandles = new List&lt;VertexBuffer&gt;(numVertexBuffers);
 _samplerStateHandles = new List&lt;SamplerState&gt;(numTextures);
 _textureHandles = new List&lt;SpectreTexture&gt;(numTextures);
 _enabledVertexAttributeArrays = new List&lt;int&gt;();

 _initializeState();
 reset();
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="device">
<button class="show-code">Code</button>
final <a href="../spectre/GraphicsDevice.html">GraphicsDevice</a>         <strong>device</strong> <a class="anchor-link"
            href="#device"
            title="Permalink to GraphicsContext.device">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final GraphicsDevice device
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="clearColorBuffer">
<button class="show-code">Code</button>
void <strong>clearColorBuffer</strong>(num r, num g, num b, num a) <a class="anchor-link" href="#clearColorBuffer"
              title="Permalink to GraphicsContext.clearColorBuffer">#</a></h4>
<div class="doc">
<pre class="source">
void clearColorBuffer(num r, num g, num b, num a) {
 device.gl.clearColor(r, g, b, a);
 device.gl.clear(WebGL.COLOR_BUFFER_BIT);
}
</pre>
</div>
</div>
<div class="method"><h4 id="clearDepthBuffer">
<button class="show-code">Code</button>
void <strong>clearDepthBuffer</strong>(num depth) <a class="anchor-link" href="#clearDepthBuffer"
              title="Permalink to GraphicsContext.clearDepthBuffer">#</a></h4>
<div class="doc">
<pre class="source">
void clearDepthBuffer(num depth) {
 device.gl.clearDepth(depth);
 device.gl.clear(WebGL.DEPTH_BUFFER_BIT);
}
</pre>
</div>
</div>
<div class="method"><h4 id="clearStencilBuffer">
<button class="show-code">Code</button>
void <strong>clearStencilBuffer</strong>(int stencil) <a class="anchor-link" href="#clearStencilBuffer"
              title="Permalink to GraphicsContext.clearStencilBuffer">#</a></h4>
<div class="doc">
<pre class="source">
void clearStencilBuffer(int stencil) {
 device.gl.clearStencil(stencil);
 device.gl.clear(WebGL.STENCIL_BUFFER_BIT);
}
</pre>
</div>
</div>
<div class="method"><h4 id="draw">
<button class="show-code">Code</button>
void <strong>draw</strong>(int numVertices, int vertexOffset) <a class="anchor-link" href="#draw"
              title="Permalink to GraphicsContext.draw">#</a></h4>
<div class="doc">
<p>Draw a mesh with 
<span class="param">numVertices</span> starting at 
<span class="param">vertexOffset</span></p>
<pre class="source">
void draw(int numVertices, int vertexOffset) {
 if (numVertices == 0) {
   return;
 }
 _prepareInputs();
 _prepareTextures();
 device.gl.drawArrays(_primitiveTopology, vertexOffset, numVertices);
}
</pre>
</div>
</div>
<div class="method"><h4 id="drawIndexed">
<button class="show-code">Code</button>
void <strong>drawIndexed</strong>(int numIndices, int indexOffset) <a class="anchor-link" href="#drawIndexed"
              title="Permalink to GraphicsContext.drawIndexed">#</a></h4>
<div class="doc">
<p>Draw an indexed mesh with 
<span class="param">numIndices</span> starting at 
<span class="param">indexOffset</span></p>
<pre class="source">
void drawIndexed(int numIndices, int indexOffset) {
 if (numIndices == 0) {
   return;
 }
 _prepareInputs();
 _prepareTextures();
 device.gl.drawElements(_primitiveTopology, numIndices,
                        WebGL.UNSIGNED_SHORT, indexOffset);
}
</pre>
</div>
</div>
<div class="method"><h4 id="drawIndexedMesh">
<button class="show-code">Code</button>
void <strong>drawIndexedMesh</strong>(<a href="../spectre/SingleArrayIndexedMesh.html">SingleArrayIndexedMesh</a> indexedMesh) <a class="anchor-link" href="#drawIndexedMesh"
              title="Permalink to GraphicsContext.drawIndexedMesh">#</a></h4>
<div class="doc">
<pre class="source">
void drawIndexedMesh(SingleArrayIndexedMesh indexedMesh) {
 if (indexedMesh == null) {
   return;
 }
 drawIndexed(indexedMesh.count, 0);
}
</pre>
</div>
</div>
<div class="method"><h4 id="drawMesh">
<button class="show-code">Code</button>
void <strong>drawMesh</strong>(<a href="../spectre/SingleArrayMesh.html">SingleArrayMesh</a> mesh) <a class="anchor-link" href="#drawMesh"
              title="Permalink to GraphicsContext.drawMesh">#</a></h4>
<div class="doc">
<pre class="source">
void drawMesh(SingleArrayMesh mesh) {
 if (mesh == null) {
   return;
 }
 draw(mesh.count, 0);
}
</pre>
</div>
</div>
<div class="method"><h4 id="reset">
<button class="show-code">Code</button>
void <strong>reset</strong>() <a class="anchor-link" href="#reset"
              title="Permalink to GraphicsContext.reset">#</a></h4>
<div class="doc">
<p>Resets the cached GPU pipeline state</p>
<pre class="source">
void reset() {
 // TODO: Update GPU state
 _primitiveTopology = 0;
 for (int index in _enabledVertexAttributeArrays) {
   if (index == 0) {
     continue;
   }
   device.gl.disableVertexAttribArray(index);
 }
 _preparedInputLayoutHandle = null;
 _enabledVertexAttributeArrays.clear();
 _indexBufferHandle = null;
 for (int i = 0; i &lt; numVertexBuffers; i++) {
   _vertexBufferHandles[i] = null;
 }
 _inputLayoutHandle = null;
 _shaderProgramHandle = null;
 for (int i = 0; i &lt; numTextures; i++) {
   _samplerStateHandles[i] = null;
   _textureHandles[i] = null;
 }
 _stencilStateHandle = null;
 _renderTargetHandle = null;

 setBlendState(_blendStateDefault);
 setDepthState(_depthStateDefault);
 setRasterizerState(_rasterizerStateDefault);
}
</pre>
</div>
</div>
<div class="method"><h4 id="setBlendState">
<button class="show-code">Code</button>
void <strong>setBlendState</strong>(<a href="../spectre/BlendState.html">BlendState</a> blendState) <a class="anchor-link" href="#setBlendState"
              title="Permalink to GraphicsContext.setBlendState">#</a></h4>
<div class="doc">
<p>Sets the current <a class="crossref" href="../spectre/BlendState.html">BlendState</a> to use on the pipeline.</p>
<p>If 
<span class="param">blendState</span> is null all values of the pipeline associated with blending
will be reset to their defaults.</p>
<pre class="source">
void setBlendState(BlendState blendState) {
 if (blendState == null) {
   setBlendState(_blendStateDefault);
   return;
 }

 // Disable/Enable blending if necessary
 if (_blendState.enabled != blendState.enabled) {
   if (blendState.enabled) {
     device.gl.enable(WebGL.BLEND);
   } else {
     device.gl.disable(WebGL.BLEND);
   }

   _blendState.enabled = blendState.enabled;
 }

 // Modify the color write channels if necessary
 if ((_blendState.writeRenderTargetRed   != blendState.writeRenderTargetRed)   ||
     (_blendState.writeRenderTargetGreen != blendState.writeRenderTargetGreen) ||
     (_blendState.writeRenderTargetBlue  != blendState.writeRenderTargetBlue)  ||
     (_blendState.writeRenderTargetAlpha != blendState.writeRenderTargetAlpha))
 {
   device.gl.colorMask(
     blendState.writeRenderTargetRed,
     blendState.writeRenderTargetGreen,
     blendState.writeRenderTargetBlue,
     blendState.writeRenderTargetAlpha
   );

   _blendState.writeRenderTargetRed   = blendState.writeRenderTargetRed;
   _blendState.writeRenderTargetGreen = blendState.writeRenderTargetGreen;
   _blendState.writeRenderTargetBlue  = blendState.writeRenderTargetBlue;
   _blendState.writeRenderTargetAlpha = blendState.writeRenderTargetAlpha;
 }

 // If blending is enabled enable all the functionality
 if (_blendState.enabled) {
   // Modify the blend functions if necessary
   if ((_blendState.colorSourceBlend      != blendState.colorSourceBlend)      ||
       (_blendState.colorDestinationBlend != blendState.colorDestinationBlend) ||
       (_blendState.alphaSourceBlend      != blendState.alphaSourceBlend)      ||
       (_blendState.alphaDestinationBlend != blendState.alphaDestinationBlend))
   {
     device.gl.blendFuncSeparate(
       blendState.colorSourceBlend,
       blendState.colorDestinationBlend,
       blendState.alphaSourceBlend,
       blendState.alphaDestinationBlend
     );

     _blendState.colorSourceBlend      = blendState.colorSourceBlend;
     _blendState.colorDestinationBlend = blendState.colorDestinationBlend;
     _blendState.alphaSourceBlend      = blendState.alphaSourceBlend;
     _blendState.alphaDestinationBlend = blendState.alphaDestinationBlend;
   }

   // Modify the blend operations if necessary
   if ((_blendState.colorBlendOperation != blendState.colorBlendOperation) ||
       (_blendState.alphaBlendOperation != blendState.alphaBlendOperation))
   {
     device.gl.blendEquationSeparate(blendState.colorBlendOperation, blendState.alphaBlendOperation);

     _blendState.colorBlendOperation = blendState.colorBlendOperation;
     _blendState.alphaBlendOperation = blendState.alphaBlendOperation;
   }

   // Modify the blend factor if necessary
   if ((_blendState.blendFactorRed   != blendState.blendFactorRed)   ||
       (_blendState.blendFactorGreen != blendState.blendFactorGreen) ||
       (_blendState.blendFactorBlue  != blendState.blendFactorBlue)  ||
       (_blendState.blendFactorAlpha != blendState.blendFactorAlpha))
   {
     device.gl.blendColor(
       blendState.blendFactorRed,
       blendState.blendFactorGreen,
       blendState.blendFactorBlue,
       blendState.blendFactorAlpha
     );

     _blendState.blendFactorRed   = blendState.blendFactorRed;
     _blendState.blendFactorGreen = blendState.blendFactorGreen;
     _blendState.blendFactorBlue  = blendState.blendFactorBlue;
     _blendState.blendFactorAlpha = blendState.blendFactorAlpha;
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="setConstant">
<button class="show-code">Code</button>
void <strong>setConstant</strong>(String name, argument) <a class="anchor-link" href="#setConstant"
              title="Permalink to GraphicsContext.setConstant">#</a></h4>
<div class="doc">
<pre class="source">
void setConstant(String name, var argument) {
 ShaderProgramUniform uniform = _findUniform(name);
 if (uniform != null) {
   uniform._apply(device, uniform.location, argument);
 } else if (_shaderProgramHandle == null ){
   spectreLog.Error('Cannot set $name: no ShaderProgram bound.');
 } else {
   //spectreLog.Error('Cannot set $name: not found.');
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="setDepthState">
<button class="show-code">Code</button>
void <strong>setDepthState</strong>(<a href="../spectre/DepthState.html">DepthState</a> depthState) <a class="anchor-link" href="#setDepthState"
              title="Permalink to GraphicsContext.setDepthState">#</a></h4>
<div class="doc">
<p>Sets the current <a class="crossref" href="../spectre/DepthState.html">DepthState</a> to use on the pipeline.</p>
<p>If 
<span class="param">depthState</span> is null all values of the pipeline associated with depth
will be reset to their defaults.</p>
<pre class="source">
void setDepthState(DepthState depthState) {
 if (depthState == null) {
   return;
 }

 if (_depthState.depthBufferEnabled != depthState.depthBufferEnabled) {
   if (depthState.depthBufferEnabled) {
     device.gl.enable(WebGL.DEPTH_TEST);
   } else {
     device.gl.disable(WebGL.DEPTH_TEST);
   }

   _depthState.depthBufferEnabled = depthState.depthBufferEnabled;
 }

 if ((_depthState.depthBufferEnabled) &amp;&amp; (_depthState.depthBufferFunction != depthState.depthBufferFunction)) {
   device.gl.depthFunc(depthState.depthBufferFunction);

   _depthState.depthBufferFunction = depthState.depthBufferFunction;
 }

 if (_depthState.depthBufferWriteEnabled != depthState.depthBufferWriteEnabled) {
   device.gl.depthMask(depthState.depthBufferWriteEnabled);

   _depthState.depthBufferWriteEnabled = depthState.depthBufferWriteEnabled;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="setIndexBuffer">
<button class="show-code">Code</button>
void <strong>setIndexBuffer</strong>(<a href="../spectre/IndexBuffer.html">IndexBuffer</a> indexBufferHandle) <a class="anchor-link" href="#setIndexBuffer"
              title="Permalink to GraphicsContext.setIndexBuffer">#</a></h4>
<div class="doc">
<p>Set the IndexBuffer to 
<span class="param">indexBufferHandle</span></p>
<pre class="source">
void setIndexBuffer(IndexBuffer indexBufferHandle) {
 _indexBufferHandle = indexBufferHandle;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setIndexedMesh">
<button class="show-code">Code</button>
void <strong>setIndexedMesh</strong>(<a href="../spectre/SingleArrayIndexedMesh.html">SingleArrayIndexedMesh</a> indexedMesh) <a class="anchor-link" href="#setIndexedMesh"
              title="Permalink to GraphicsContext.setIndexedMesh">#</a></h4>
<div class="doc">
<pre class="source">
void setIndexedMesh(SingleArrayIndexedMesh indexedMesh) {
 if (indexedMesh == null) {
   return;
 }
 setPrimitiveTopology(indexedMesh.primitiveTopology);
 setIndexBuffer(indexedMesh.indexArray);
 setVertexBuffers(0, [indexedMesh.vertexArray]);
}
</pre>
</div>
</div>
<div class="method"><h4 id="setInputLayout">
<button class="show-code">Code</button>
void <strong>setInputLayout</strong>(<a href="../spectre/InputLayout.html">InputLayout</a> inputLayoutHandle) <a class="anchor-link" href="#setInputLayout"
              title="Permalink to GraphicsContext.setInputLayout">#</a></h4>
<div class="doc">
<p>Set InputLayout to 
<span class="param">inputLayoutHandle</span></p>
<pre class="source">
void setInputLayout(InputLayout inputLayoutHandle) {
 _inputLayoutHandle = inputLayoutHandle;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setMesh">
<button class="show-code">Code</button>
void <strong>setMesh</strong>(<a href="../spectre/SingleArrayMesh.html">SingleArrayMesh</a> mesh) <a class="anchor-link" href="#setMesh"
              title="Permalink to GraphicsContext.setMesh">#</a></h4>
<div class="doc">
<pre class="source">
void setMesh(SingleArrayMesh mesh) {
 if (mesh == null) {
   return;
 }
 setPrimitiveTopology(mesh.primitiveTopology);
 setIndexBuffer(null);
 setVertexBuffers(0, [mesh.vertexArray]);
}
</pre>
</div>
</div>
<div class="method"><h4 id="setPrimitiveTopology">
<button class="show-code">Code</button>
void <strong>setPrimitiveTopology</strong>(int topology) <a class="anchor-link" href="#setPrimitiveTopology"
              title="Permalink to GraphicsContext.setPrimitiveTopology">#</a></h4>
<div class="doc">
<p>Configure the primitive topology</p>
<pre class="source">
void setPrimitiveTopology(int topology) {
 _primitiveTopology = topology;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setRasterizerState">
<button class="show-code">Code</button>
void <strong>setRasterizerState</strong>(<a href="../spectre/RasterizerState.html">RasterizerState</a> rasterizerState) <a class="anchor-link" href="#setRasterizerState"
              title="Permalink to GraphicsContext.setRasterizerState">#</a></h4>
<div class="doc">
<p>Sets the current <a class="crossref" href="../spectre/RasterizerState.html">RasterizerState</a> to use on the pipeline.</p>
<p>If 
<span class="param">rasterizerState</span> is null all values of the pipeline associated with rasterization
will be reset to their defaults.</p>
<pre class="source">
void setRasterizerState(RasterizerState rasterizerState) {
 if (rasterizerState == null) {
   setRasterizerState(_rasterizerStateDefault);
   return;
 }

 // Disable/Enable culling if necessary
 if (_rasterizerState.cullMode != rasterizerState.cullMode) {
   if (rasterizerState.cullMode == CullMode.None) {
     device.gl.disable(WebGL.CULL_FACE);

     _rasterizerState.cullMode = rasterizerState.cullMode;
   } else if (_rasterizerState.cullMode == CullMode.None) {
     device.gl.enable(WebGL.CULL_FACE);
   }
 }

 // If culling is enabled enable culling mode and winding order
 if (rasterizerState.cullMode != CullMode.None) {
   // Modify the cull mode if necessary
   if (_rasterizerState.cullMode != rasterizerState.cullMode) {
     device.gl.cullFace(rasterizerState.cullMode);

     _rasterizerState.cullMode = rasterizerState.cullMode;
   }

   // Modify the front face if necessary
   if (_rasterizerState.frontFace != rasterizerState.frontFace) {
     device.gl.frontFace(rasterizerState.frontFace);

     _rasterizerState.frontFace = rasterizerState.frontFace;
   }
 }

 bool offsetEnabled = ((_rasterizerState.depthBias != 0.0) || (_rasterizerState.slopeScaleDepthBias != 0.0));

 if ((rasterizerState.depthBias != 0.0) || (rasterizerState.slopeScaleDepthBias != 0)) {
   // Enable polygon offset
   if (!offsetEnabled) {
     device.gl.enable(WebGL.POLYGON_OFFSET_FILL);
   }

   // Modify the polygon offset if necessary
   if ((_rasterizerState.depthBias           != rasterizerState.depthBias) ||
       (_rasterizerState.slopeScaleDepthBias != rasterizerState.slopeScaleDepthBias))
   {
     device.gl.polygonOffset(rasterizerState.depthBias, rasterizerState.slopeScaleDepthBias);

     _rasterizerState.depthBias           = rasterizerState.depthBias;
     _rasterizerState.slopeScaleDepthBias = rasterizerState.slopeScaleDepthBias;
   }
 } else {
   // Disable polygon offset
   if (offsetEnabled) {
     device.gl.disable(WebGL.POLYGON_OFFSET_FILL);

     _rasterizerState.depthBias           = rasterizerState.depthBias;
     _rasterizerState.slopeScaleDepthBias = rasterizerState.slopeScaleDepthBias;
   }
 }

 // Disable/Enable scissor test if necessary
 if (_rasterizerState.scissorTestEnabled != rasterizerState.scissorTestEnabled) {
   if (rasterizerState.scissorTestEnabled) {
     device.gl.enable(WebGL.SCISSOR_TEST);
   } else {
     device.gl.disable(WebGL.SCISSOR_TEST);
   }

   _rasterizerState.scissorTestEnabled = rasterizerState.scissorTestEnabled;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="setRenderTarget">
<button class="show-code">Code</button>
void <strong>setRenderTarget</strong>(<a href="../spectre/RenderTarget.html">RenderTarget</a> renderTargetHandle) <a class="anchor-link" href="#setRenderTarget"
              title="Permalink to GraphicsContext.setRenderTarget">#</a></h4>
<div class="doc">
<p>Set RenderTarget to 
<span class="param">renderTargetHandle</span></p>
<pre class="source">
void setRenderTarget(RenderTarget renderTargetHandle) {
 _renderTargetHandle = renderTargetHandle;
 _renderTargetHandle._bind();
}
</pre>
</div>
</div>
<div class="method"><h4 id="setSamplers">
<button class="show-code">Code</button>
void <strong>setSamplers</strong>(int texUnitOffset, List&lt;<a href="../spectre/SamplerState.html">SamplerState</a>&gt; samplerHandles) <a class="anchor-link" href="#setSamplers"
              title="Permalink to GraphicsContext.setSamplers">#</a></h4>
<div class="doc">
<p>Sets a list of 
<span class="param">samplerHandles</span> starting at 
<span class="param">texUnitOffset</span></p>
<pre class="source">
void setSamplers(int texUnitOffset, List&lt;SamplerState&gt; samplerHandles) {
 for (int i = texUnitOffset; i &lt; samplerHandles.length; i++) {
   _samplerStateHandles[i] = samplerHandles[i-texUnitOffset];
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="setShaderProgram">
<button class="show-code">Code</button>
void <strong>setShaderProgram</strong>(<a href="../spectre/ShaderProgram.html">ShaderProgram</a> shaderProgramHandle) <a class="anchor-link" href="#setShaderProgram"
              title="Permalink to GraphicsContext.setShaderProgram">#</a></h4>
<div class="doc">
<p>Set ShaderProgram to 
<span class="param">shaderProgramHandle</span></p>
<pre class="source">
void setShaderProgram(ShaderProgram shaderProgramHandle) {
 if (_shaderProgramHandle == shaderProgramHandle) {
   return;
 }
 _shaderProgramHandle = shaderProgramHandle;
 ShaderProgram sp = shaderProgramHandle;
 device.gl.useProgram(sp._program);
}
</pre>
</div>
</div>
<div class="method"><h4 id="setTextures">
<button class="show-code">Code</button>
void <strong>setTextures</strong>(int texUnitOffset, List&lt;<a href="../spectre/SpectreTexture.html">SpectreTexture</a>&gt; textureHandles) <a class="anchor-link" href="#setTextures"
              title="Permalink to GraphicsContext.setTextures">#</a></h4>
<div class="doc">
<p>Sets a list of 
<span class="param">textureHandles</span> starting at 
<span class="param">texUnitOffset</span></p>
<pre class="source">
void setTextures(int texUnitOffset, List&lt;SpectreTexture&gt; textureHandles) {
 for (int i = texUnitOffset; i &lt; textureHandles.length; i++) {
   _textureHandles[i] = textureHandles[i-texUnitOffset];
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="setVertexBuffers">
<button class="show-code">Code</button>
void <strong>setVertexBuffers</strong>(int startSlot, List&lt;<a href="../spectre/VertexBuffer.html">VertexBuffer</a>&gt; vertexBufferHandles) <a class="anchor-link" href="#setVertexBuffers"
              title="Permalink to GraphicsContext.setVertexBuffers">#</a></h4>
<div class="doc">
<p>Set multiple VertexBuffers in 
<span class="param">vertexBufferHandles</span> starting at 
<span class="param">startSlot</span></p>
<pre class="source">
void setVertexBuffers(int startSlot, List&lt;VertexBuffer&gt; vertexBufferHandles) {
 int limit = vertexBufferHandles.length + startSlot;
 for (int i = startSlot; i &lt; limit; i++) {
   _vertexBufferHandles[i] = vertexBufferHandles[i-startSlot];
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="setViewport">
<button class="show-code">Code</button>
void <strong>setViewport</strong>(<a href="../spectre/Viewport.html">Viewport</a> viewport) <a class="anchor-link" href="#setViewport"
              title="Permalink to GraphicsContext.setViewport">#</a></h4>
<div class="doc">
<p>Sets a <a class="crossref" href="../spectre/Viewport.html">Viewport</a> identifying the portion of the render target to receive draw calls.</p>
<pre class="source">
void setViewport(Viewport viewport) {
 if (viewport == null) {
   return;
 }

 if ((_viewport.x      != viewport.x)     ||
     (_viewport.y      != viewport.y)     ||
     (_viewport.width  != viewport.width) ||
     (_viewport.height != viewport.height))
 {
   device.gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

   _viewport.x      = viewport.x;
   _viewport.y      = viewport.y;
   _viewport.width  = viewport.width;
   _viewport.height = viewport.height;
 }

 if ((_viewport.minDepth != viewport.minDepth) || (_viewport.maxDepth != viewport.maxDepth)) {
   device.gl.depthRange(viewport.minDepth, viewport.maxDepth);

   _viewport.minDepth = viewport.minDepth;
   _viewport.maxDepth = viewport.maxDepth;
 }
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-06-13 15:38:32.856</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
