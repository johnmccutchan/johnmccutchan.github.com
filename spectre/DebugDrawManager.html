        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>DebugDrawManager class / spectre Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="spectre" data-type="DebugDrawManager">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../spectre.html">spectre</a> &rsaquo; <a href="../spectre/DebugDrawManager.html">DebugDrawManager</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>DebugDrawManager</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>The debug draw manager manages a collection of debug primitives that are
drawn each frame. Each debug primitive has a lifetime and the manager
continues to draw each primitive until its lifetime has expired.</p>
<p>The following primitives are supported:</p><ul><li>Lines</li><li>Crosses</li><li>Spheres</li><li>Circles</li><li>Arcs</li><li>Transformations (coordinate axes)</li><li>Triangles</li><li>AABB (Axis Aligned Bounding Boxes)</li></ul>
<p>The following properties can be controlled for each primitive:</p><ul><li>Depth testing on or off.</li><li>Size.</li><li>Color.</li><li>Lifetime.</li></ul>
<pre class="source">
class DebugDrawManager {
 DepthState _depthState;
 BlendState _blendState;
 RasterizerState _rasterizerState;
 VertexShader _lineVertexShader;
 FragmentShader _lineFragmentShader;
 ShaderProgram _lineShaderProgram;
 _DebugDrawLineManager _depthEnabledLines;
 _DebugDrawLineManager _depthDisabledLines;

 Float32List _cameraMatrix = new Float32List(16);

 final GraphicsDevice device;

 /** Construct and initialize a DebugDrawManager. Can specify maximum
  * number of vertices with [maxVertices]. */
 DebugDrawManager(this.device, {int maxVertices: 16384}) {
   _depthState = new DepthState('DebugDrawManager', device);
   _blendState = new BlendState.alphaBlend('DebugDrawManager', device);
   _rasterizerState = new RasterizerState('DebugDrawManager', device);
   _rasterizerState.cullMode = CullMode.None;
   _lineVertexShader = new VertexShader('DebugDrawManager', device);
   _lineFragmentShader = new FragmentShader('DebugDrawManager', device);
   _lineShaderProgram = new ShaderProgram('DebugDrawManager', device);
   _lineVertexShader.source = _debugLineVertexShader;
   _lineFragmentShader.source = _debugLineFragmentShader;
   _lineShaderProgram.vertexShader = _lineVertexShader;
   _lineShaderProgram.fragmentShader = _lineFragmentShader;
   _lineShaderProgram.link();
   _depthEnabledLines = new _DebugDrawLineManager(device,
                                                  maxVertices,
                                                  _lineShaderProgram);
   _depthDisabledLines = new _DebugDrawLineManager(device,
                                                   maxVertices,
                                                   _lineShaderProgram);
 }



 /** Add a line primitive extending from [start] to [finish].
  * Filled with [color].
  *
  * Optional parameters: [duration] and [depthEnabled].
  */
 void addLine(Vector3 start, Vector3 finish, Vector4 color,
              {num duration: 0.0, bool depthEnabled: true}) {
   var lineManager = depthEnabled ? _depthEnabledLines : _depthDisabledLines;
   lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
                                     duration);
   lineManager.lines._addLine(start, finish);
   lineManager.lines.finishLineObject();
 }

 /** Add a cross primitive at [point]. Filled with [color].
  *
  * Optional paremeters: [size], [duration], and [depthEnabled].
  */
 void addCross(Vector3 point, Vector4 color,
               {num size: 1.0, num duration: 0.0, bool depthEnabled:true}) {
   var lineManager = depthEnabled ? _depthEnabledLines : _depthDisabledLines;
   lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
                                     duration);
   num half_size = size * 0.5;
   lineManager.lines._addLine(point, point + new Vector3(half_size, 0.0, 0.0));
   lineManager.lines._addLine(point, point + new Vector3(-half_size, 0.0, 0.0));
   lineManager.lines._addLine(point, point + new Vector3(0.0, half_size, 0.0));
   lineManager.lines._addLine(point, point + new Vector3(0.0, -half_size, 0.0));
   lineManager.lines._addLine(point, point + new Vector3(0.0, 0.0, half_size));
   lineManager.lines._addLine(point, point + new Vector3(0.0, 0.0, -half_size));
   lineManager.lines.finishLineObject();
 }

 /** Add a sphere primitive at [center] with [radius]. Filled with [color].
  *
  * Optional paremeters: [duration] and [depthEnabled].
  */
 void addSphere(Vector3 center, num radius, Vector4 color,
                {num duration: 0.0, bool depthEnabled: true}) {
   var lineManager = depthEnabled ? _depthEnabledLines : _depthDisabledLines;
   lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
                                     duration);

   int latSegments = 6;
   int lonSegments = 8;
   num twoPi = (2.0 * Math.PI);

   Vector3 lastVertex, vertex, upperVertex;

   for (int y = 0; y &lt; latSegments; ++y) {
     lastVertex = null;
     for (int x = 0; x &lt;= lonSegments; ++x) {
       num u = x / lonSegments;
       num v = y / latSegments;
       num v2 = (y+1) / latSegments;

       vertex = new Vector3(
           radius * Math.cos(u * twoPi) * Math.sin(v * Math.PI),
           radius * Math.cos(v * Math.PI),
           radius * Math.sin(u * twoPi) * Math.sin(v * Math.PI)
       ) + center;

       upperVertex = new Vector3(
           radius * Math.cos(u * twoPi) * Math.sin(v2 * Math.PI),
           radius * Math.cos(v2 * Math.PI),
           radius * Math.sin(u * twoPi) * Math.sin(v2 * Math.PI)
       ) + center;

       if(lastVertex != null) {
         lineManager.lines._addLineRaw(
             lastVertex.x, lastVertex.y, lastVertex.z,
             vertex.x, vertex.y, vertex.z);
         lineManager.lines._addLineRaw(
             upperVertex.x, upperVertex.y, upperVertex.z,
             vertex.x, vertex.y, vertex.z);
       }

       lastVertex = vertex;
     }
   }
   lineManager.lines.finishLineObject();
 }

 final Vector3 _circle_u = new Vector3.zero();
 final Vector3 _circle_v = new Vector3.zero();

 /** Add an arc primitive at [center] in the plane whose normal is
  * [planeNormal] with a [radius]. The arc begins at [startAngle] and extends
  * to [stopAngle]. Filled with [color].
  *
  * Optional parameters: [duration], [depthEnabled], and [numSegments].
  */
 void addArc(Vector3 center, Vector3 planeNormal, num radius, num startAngle,
             num stopAngle, Vector4 color, {num duration: 0.0,
             bool depthEnabled: true, int numSegments: 16}) {
   var lineManager = depthEnabled ? _depthEnabledLines : _depthDisabledLines;
   lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
                                     duration);

   buildPlaneVectors(planeNormal, _circle_u, _circle_v);
   num alpha = 0.0;
   num twoPi = (2.0 * 3.141592653589793238462643);
   num _step = twoPi/numSegments;

   alpha = startAngle;
   double cosScale = Math.cos(alpha) * radius;
   double sinScale = Math.sin(alpha) * radius;
   double lastX = center.x + cosScale * _circle_u.x + sinScale * _circle_v.x;
   double lastY = center.y + cosScale * _circle_u.y + sinScale * _circle_v.y;
   double lastZ = center.z + cosScale * _circle_u.z + sinScale * _circle_v.z;

   for (alpha = startAngle; alpha &lt;= stopAngle+_step; alpha += _step) {
     cosScale = Math.cos(alpha) * radius;
     sinScale = Math.sin(alpha) * radius;
     double pX = center.x + cosScale * _circle_u.x + sinScale * _circle_v.x;
     double pY = center.y + cosScale * _circle_u.y + sinScale * _circle_v.y;
     double pZ = center.z + cosScale * _circle_u.z + sinScale * _circle_v.z;
     lineManager.lines._addLineRaw(lastX, lastY, lastZ, pX, pY, pZ);
     lastX = pX;
     lastY = pY;
     lastZ = pZ;
   }
   lineManager.lines.finishLineObject();
 }

 /** Add an circle primitive at [center] in the plane whose normal is
  * [planeNormal] with a [radius]. Filled with [color].
  *
  * Optional parameters: [duration], [depthEnabled], and [numSegments].
  */
 void addCircle(Vector3 center, Vector3 planeNormal, num radius, Vector4 color,
                {num duration: 0.0, bool depthEnabled: true,
                int numSegments: 16}) {
   var lineManager = depthEnabled ? _depthEnabledLines : _depthDisabledLines;
   lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
                                     duration);

   buildPlaneVectors(planeNormal, _circle_u, _circle_v);
   num alpha = 0.0;
   num twoPi = (2.0 * 3.141592653589793238462643);
   num _step = twoPi/numSegments;

   double lastX = center.x + _circle_u.x * radius;
   double lastY = center.y + _circle_u.y * radius;
   double lastZ = center.z + _circle_u.z * radius;

   for (alpha = 0.0; alpha &lt;= twoPi; alpha += _step) {
     double cosScale = Math.cos(alpha) * radius;
     double sinScale = Math.sin(alpha) * radius;
     double pX = center.x + cosScale * _circle_u.x + sinScale * _circle_v.x;
     double pY = center.y + cosScale * _circle_u.y + sinScale * _circle_v.y;
     double pZ = center.z + cosScale * _circle_u.z + sinScale * _circle_v.z;
     lineManager.lines._addLineRaw(lastX, lastY, lastZ, pX, pY, pZ);
     lastX = pX;
     lastY = pY;
     lastZ = pZ;
   }
   lineManager.lines._addLineRaw(lastX, lastY, lastZ,
                                 center.x + _circle_u.x * radius,
                                 center.y + _circle_u.y * radius,
                                 center.z + _circle_u.z * radius);
   lineManager.lines.finishLineObject();
 }

 /// Add a coordinate system primitive. Derived from [xform]. Scaled by [size].
 ///
 /// X,Y, and Z axes are colored Red,Green, and Blue
 ///
 /// Optional paremeters: [duration], and [depthEnabled]
 void addAxes(Matrix4 xform, num size,
              {num duration: 0.0, bool depthEnabled: true}) {
   var lineManager = depthEnabled ? _depthEnabledLines : _depthDisabledLines;

   Vector4 origin = new Vector4(0.0, 0.0, 0.0, 1.0);
   num size_90p = 0.9 * size;
   num size_10p = 0.1 * size;

   Vector4 color;

   Vector4 X = new Vector4(size, 0.0, 0.0, 1.0);
   Vector4 X_head_0 = new Vector4(size_90p, size_10p, 0.0, 1.0);
   Vector4 X_head_1 = new Vector4(size_90p, -size_10p, 0.0, 1.0);
   Vector4 X_head_2 = new Vector4(size_90p, 0.0, size_10p, 1.0);
   Vector4 X_head_3 = new Vector4(size_90p, 0.0, -size_10p, 1.0);

   Vector4 Y = new Vector4(0.0, size, 0.0, 1.0);
   Vector4 Y_head_0 = new Vector4(size_10p, size_90p, 0.0, 1.0);
   Vector4 Y_head_1 = new Vector4(-size_10p, size_90p, 0.0, 1.0);
   Vector4 Y_head_2 = new Vector4(0.0, size_90p, size_10p, 1.0);
   Vector4 Y_head_3 = new Vector4(0.0, size_90p, -size_10p, 1.0);


   Vector4 Z = new Vector4(0.0, 0.0, size, 1.0);
   Vector4 Z_head_0 = new Vector4(size_10p, 0.0, size_90p, 1.0);
   Vector4 Z_head_1 = new Vector4(-size_10p, 0.0, size_90p, 1.0);
   Vector4 Z_head_2 = new Vector4(0.0, size_10p, size_90p, 1.0);
   Vector4 Z_head_3 = new Vector4(0.0, -size_10p, size_90p, 1.0);

   origin = xform * origin;

   X = xform * X;
   X_head_0 = xform * X_head_0;
   X_head_1 = xform * X_head_1;
   X_head_2 = xform * X_head_2;
   X_head_3 = xform * X_head_3;

   color = new Vector4(1.0, 0.0, 0.0, 1.0);
   lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
       duration);
   lineManager.lines._addLine(origin.xyz, X.xyz);
   lineManager.lines._addLine(X.xyz, X_head_0.xyz);
   lineManager.lines._addLine(X.xyz, X_head_1.xyz);
   lineManager.lines._addLine(X.xyz, X_head_2.xyz);
   lineManager.lines._addLine(X.xyz, X_head_3.xyz);
   lineManager.lines.finishLineObject();

   Y = xform * Y;
   Y_head_0 = xform * Y_head_0;
   Y_head_1 = xform * Y_head_1;
   Y_head_2 = xform * Y_head_2;
   Y_head_3 = xform * Y_head_3;

   color = new Vector4(0.0, 1.0, 0.0, 1.0);
   lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
       duration);
   lineManager.lines._addLine(origin.xyz, Y.xyz);
   lineManager.lines._addLine(Y.xyz, Y_head_0.xyz);
   lineManager.lines._addLine(Y.xyz, Y_head_1.xyz);
   lineManager.lines._addLine(Y.xyz, Y_head_2.xyz);
   lineManager.lines._addLine(Y.xyz, Y_head_3.xyz);
   lineManager.lines.finishLineObject();

   Z = xform * Z;
   Z_head_0 = xform * Z_head_0;
   Z_head_1 = xform * Z_head_1;
   Z_head_2 = xform * Z_head_2;
   Z_head_3 = xform * Z_head_3;

   color = new Vector4(0.0, 0.0, 1.0, 1.0);
   lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
       duration);
   lineManager.lines._addLine(origin.xyz, Z.xyz);
   lineManager.lines._addLine(Z.xyz, Z_head_0.xyz);
   lineManager.lines._addLine(Z.xyz, Z_head_1.xyz);
   lineManager.lines._addLine(Z.xyz, Z_head_2.xyz);
   lineManager.lines._addLine(Z.xyz, Z_head_3.xyz);
   lineManager.lines.finishLineObject();
 }

 /// Add a triangle primitives from vertices [vertex0], [vertex1],
 /// and [vertex2]. Filled with [color].
 ///
 /// Optional parameters: [duration] and [depthEnabled]
 void addTriangle(Vector3 vertex0, Vector3 vertex1, Vector3 vertex2, Vector4 color,
                  {num duration: 0.0, bool depthEnabled: true}) {
   var lineManager = depthEnabled ? _depthEnabledLines : _depthDisabledLines;
   lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
                                     duration);
   lineManager.lines._addLine(vertex0, vertex1);
   lineManager.lines._addLine(vertex1, vertex2);
   lineManager.lines._addLine(vertex2, vertex0);
   lineManager.lines.finishLineObject();
 }

 /// Add an Axis Aligned Bounding Box with corners at [boxMin] and [boxMax].
 /// Filled with [color].
 ///
 /// Option parameters: [duration] and [depthEnabled]
 void addAABB(Vector3 boxMin, Vector3 boxMax, Vector4 color,
              {num duration: 0.0, bool depthEnabled: true}) {
   Vector3 vertex_a;
   Vector3 vertex_b;

   var lineManager = depthEnabled ? _depthEnabledLines : _depthDisabledLines;
   lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
       duration);

   vertex_a = new Vector3.copy(boxMin);
   vertex_b = new Vector3.copy(vertex_a);
   vertex_b[0] = boxMax[0];
   lineManager.lines._addLine(vertex_a, vertex_b);
   vertex_b = new Vector3.copy(vertex_a);
   vertex_b[1] = boxMax[1];
   lineManager.lines._addLine(vertex_a, vertex_b);
   vertex_b = new Vector3.copy(vertex_a);
   vertex_b[2] = boxMax[2];
   lineManager.lines._addLine(vertex_a, vertex_b);
   vertex_a[1] = boxMax[1];
   vertex_b = new Vector3.copy(vertex_a);
   vertex_b[0] = boxMax[0];
   lineManager.lines._addLine(vertex_a, vertex_b);
   vertex_b = new Vector3.copy(vertex_a);
   vertex_b[2] = boxMax[2];
   lineManager.lines._addLine(vertex_a, vertex_b);
   vertex_a = new Vector3.copy(boxMin);
   vertex_a[0] = boxMax[0];
   vertex_b = new Vector3.copy(vertex_a);
   vertex_b[1] = boxMax[1];
   lineManager.lines._addLine(vertex_a, vertex_b);
   vertex_a = new Vector3.copy(boxMax);
   vertex_b = new Vector3.copy(vertex_a);
   vertex_b[0] = boxMin[0];
   lineManager.lines._addLine(vertex_a, vertex_b);
   vertex_b = new Vector3.copy(vertex_a);
   vertex_b[1] = boxMin[1];
   lineManager.lines._addLine(vertex_a, vertex_b);
   vertex_b = new Vector3.copy(vertex_a);
   vertex_b[2] = boxMin[2];
   lineManager.lines._addLine(vertex_a, vertex_b);
   vertex_a[1] = boxMin[1];
   vertex_b = new Vector3.copy(vertex_a);
   vertex_b[0] = boxMin[0];
   lineManager.lines._addLine(vertex_a, vertex_b);
   vertex_b = new Vector3.copy(vertex_a);
   vertex_b[2] = boxMin[2];
   lineManager.lines._addLine(vertex_a, vertex_b);
   vertex_a = new Vector3.copy(boxMin);
   vertex_a[2] = boxMax[2];
   vertex_b = new Vector3.copy(vertex_a);
   vertex_b[1] = boxMax[1];
   lineManager.lines._addLine(vertex_a, vertex_b);
   lineManager.lines.finishLineObject();
 }

 /// Prepare to render debug primitives
 void prepareForRender() {
   _depthEnabledLines._prepareForRender(device.context);
   _depthDisabledLines._prepareForRender(device.context);
 }

 /// Render debug primitives for [Camera] [cam]
 void render(Camera cam) {
   Matrix4 pm = cam.projectionMatrix;
   Matrix4 la = cam.viewMatrix;
   pm.multiply(la);
   pm.copyIntoArray(_cameraMatrix);
   device.context.setShaderProgram(_lineShaderProgram);
   device.context.setConstant('cameraTransform', _cameraMatrix);
   _depthState.depthBufferEnabled = true;
   _depthState.depthBufferWriteEnabled = true;
   device.context.setDepthState(_depthState);
   device.context.setBlendState(_blendState);
   device.context.setRasterizerState(_rasterizerState);
   device.context.setInputLayout(_depthEnabledLines._lineMeshInputLayout);
   device.context.setMesh(_depthEnabledLines._lineMesh);
   device.context.drawMesh(_depthEnabledLines._lineMesh);
   _depthState.depthBufferEnabled = false;
   _depthState.depthBufferWriteEnabled = false;
   device.context.setDepthState(_depthState);
   device.context.setMesh(_depthDisabledLines._lineMesh);
   device.context.drawMesh(_depthDisabledLines._lineMesh);
 }

 /// Update time [seconds], removing any dead debug primitives
 void update(num seconds) {
   _depthEnabledLines.update(seconds);
   _depthDisabledLines.update(seconds);
 }
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="DebugDrawManager">
<button class="show-code">Code</button>
new <strong>DebugDrawManager</strong>(<a href="../spectre/GraphicsDevice.html">GraphicsDevice</a> device, {int maxVertices: 16384}) <a class="anchor-link" href="#DebugDrawManager"
              title="Permalink to DebugDrawManager.DebugDrawManager">#</a></h4>
<div class="doc">
<p>Construct and initialize a DebugDrawManager. Can specify maximum
number of vertices with 
<span class="param">maxVertices</span>. </p>
<pre class="source">
DebugDrawManager(this.device, {int maxVertices: 16384}) {
 _depthState = new DepthState('DebugDrawManager', device);
 _blendState = new BlendState.alphaBlend('DebugDrawManager', device);
 _rasterizerState = new RasterizerState('DebugDrawManager', device);
 _rasterizerState.cullMode = CullMode.None;
 _lineVertexShader = new VertexShader('DebugDrawManager', device);
 _lineFragmentShader = new FragmentShader('DebugDrawManager', device);
 _lineShaderProgram = new ShaderProgram('DebugDrawManager', device);
 _lineVertexShader.source = _debugLineVertexShader;
 _lineFragmentShader.source = _debugLineFragmentShader;
 _lineShaderProgram.vertexShader = _lineVertexShader;
 _lineShaderProgram.fragmentShader = _lineFragmentShader;
 _lineShaderProgram.link();
 _depthEnabledLines = new _DebugDrawLineManager(device,
                                                maxVertices,
                                                _lineShaderProgram);
 _depthDisabledLines = new _DebugDrawLineManager(device,
                                                 maxVertices,
                                                 _lineShaderProgram);
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="device">
<button class="show-code">Code</button>
final <a href="../spectre/GraphicsDevice.html">GraphicsDevice</a>         <strong>device</strong> <a class="anchor-link"
            href="#device"
            title="Permalink to DebugDrawManager.device">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final GraphicsDevice device
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="addAABB">
<button class="show-code">Code</button>
void <strong>addAABB</strong>(<a href="../vector_math/Vector3.html">Vector3</a> boxMin, <a href="../vector_math/Vector3.html">Vector3</a> boxMax, <a href="../vector_math/Vector4.html">Vector4</a> color, {num duration: 0.0, bool depthEnabled: true}) <a class="anchor-link" href="#addAABB"
              title="Permalink to DebugDrawManager.addAABB">#</a></h4>
<div class="doc">
<p>Add an Axis Aligned Bounding Box with corners at 
<span class="param">boxMin</span> and 
<span class="param">boxMax</span>.
Filled with 
<span class="param">color</span>.</p>
<p>Option parameters: 
<span class="param">duration</span> and 
<span class="param">depthEnabled</span></p>
<pre class="source">
void addAABB(Vector3 boxMin, Vector3 boxMax, Vector4 color,
            {num duration: 0.0, bool depthEnabled: true}) {
 Vector3 vertex_a;
 Vector3 vertex_b;

 var lineManager = depthEnabled ? _depthEnabledLines : _depthDisabledLines;
 lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
     duration);

 vertex_a = new Vector3.copy(boxMin);
 vertex_b = new Vector3.copy(vertex_a);
 vertex_b[0] = boxMax[0];
 lineManager.lines._addLine(vertex_a, vertex_b);
 vertex_b = new Vector3.copy(vertex_a);
 vertex_b[1] = boxMax[1];
 lineManager.lines._addLine(vertex_a, vertex_b);
 vertex_b = new Vector3.copy(vertex_a);
 vertex_b[2] = boxMax[2];
 lineManager.lines._addLine(vertex_a, vertex_b);
 vertex_a[1] = boxMax[1];
 vertex_b = new Vector3.copy(vertex_a);
 vertex_b[0] = boxMax[0];
 lineManager.lines._addLine(vertex_a, vertex_b);
 vertex_b = new Vector3.copy(vertex_a);
 vertex_b[2] = boxMax[2];
 lineManager.lines._addLine(vertex_a, vertex_b);
 vertex_a = new Vector3.copy(boxMin);
 vertex_a[0] = boxMax[0];
 vertex_b = new Vector3.copy(vertex_a);
 vertex_b[1] = boxMax[1];
 lineManager.lines._addLine(vertex_a, vertex_b);
 vertex_a = new Vector3.copy(boxMax);
 vertex_b = new Vector3.copy(vertex_a);
 vertex_b[0] = boxMin[0];
 lineManager.lines._addLine(vertex_a, vertex_b);
 vertex_b = new Vector3.copy(vertex_a);
 vertex_b[1] = boxMin[1];
 lineManager.lines._addLine(vertex_a, vertex_b);
 vertex_b = new Vector3.copy(vertex_a);
 vertex_b[2] = boxMin[2];
 lineManager.lines._addLine(vertex_a, vertex_b);
 vertex_a[1] = boxMin[1];
 vertex_b = new Vector3.copy(vertex_a);
 vertex_b[0] = boxMin[0];
 lineManager.lines._addLine(vertex_a, vertex_b);
 vertex_b = new Vector3.copy(vertex_a);
 vertex_b[2] = boxMin[2];
 lineManager.lines._addLine(vertex_a, vertex_b);
 vertex_a = new Vector3.copy(boxMin);
 vertex_a[2] = boxMax[2];
 vertex_b = new Vector3.copy(vertex_a);
 vertex_b[1] = boxMax[1];
 lineManager.lines._addLine(vertex_a, vertex_b);
 lineManager.lines.finishLineObject();
}
</pre>
</div>
</div>
<div class="method"><h4 id="addArc">
<button class="show-code">Code</button>
void <strong>addArc</strong>(<a href="../vector_math/Vector3.html">Vector3</a> center, <a href="../vector_math/Vector3.html">Vector3</a> planeNormal, num radius, num startAngle, num stopAngle, <a href="../vector_math/Vector4.html">Vector4</a> color, {num duration: 0.0, bool depthEnabled: true, int numSegments: 16}) <a class="anchor-link" href="#addArc"
              title="Permalink to DebugDrawManager.addArc">#</a></h4>
<div class="doc">
<p>Add an arc primitive at 
<span class="param">center</span> in the plane whose normal is

<span class="param">planeNormal</span> with a 
<span class="param">radius</span>. The arc begins at 
<span class="param">startAngle</span> and extends
to 
<span class="param">stopAngle</span>. Filled with 
<span class="param">color</span>.</p>
<p>Optional parameters: 
<span class="param">duration</span>, 
<span class="param">depthEnabled</span>, and 
<span class="param">numSegments</span>.</p>
<pre class="source">
void addArc(Vector3 center, Vector3 planeNormal, num radius, num startAngle,
           num stopAngle, Vector4 color, {num duration: 0.0,
           bool depthEnabled: true, int numSegments: 16}) {
 var lineManager = depthEnabled ? _depthEnabledLines : _depthDisabledLines;
 lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
                                   duration);

 buildPlaneVectors(planeNormal, _circle_u, _circle_v);
 num alpha = 0.0;
 num twoPi = (2.0 * 3.141592653589793238462643);
 num _step = twoPi/numSegments;

 alpha = startAngle;
 double cosScale = Math.cos(alpha) * radius;
 double sinScale = Math.sin(alpha) * radius;
 double lastX = center.x + cosScale * _circle_u.x + sinScale * _circle_v.x;
 double lastY = center.y + cosScale * _circle_u.y + sinScale * _circle_v.y;
 double lastZ = center.z + cosScale * _circle_u.z + sinScale * _circle_v.z;

 for (alpha = startAngle; alpha &lt;= stopAngle+_step; alpha += _step) {
   cosScale = Math.cos(alpha) * radius;
   sinScale = Math.sin(alpha) * radius;
   double pX = center.x + cosScale * _circle_u.x + sinScale * _circle_v.x;
   double pY = center.y + cosScale * _circle_u.y + sinScale * _circle_v.y;
   double pZ = center.z + cosScale * _circle_u.z + sinScale * _circle_v.z;
   lineManager.lines._addLineRaw(lastX, lastY, lastZ, pX, pY, pZ);
   lastX = pX;
   lastY = pY;
   lastZ = pZ;
 }
 lineManager.lines.finishLineObject();
}
</pre>
</div>
</div>
<div class="method"><h4 id="addAxes">
<button class="show-code">Code</button>
void <strong>addAxes</strong>(<a href="../vector_math/Matrix4.html">Matrix4</a> xform, num size, {num duration: 0.0, bool depthEnabled: true}) <a class="anchor-link" href="#addAxes"
              title="Permalink to DebugDrawManager.addAxes">#</a></h4>
<div class="doc">
<p>Add a coordinate system primitive. Derived from 
<span class="param">xform</span>. Scaled by 
<span class="param">size</span>.</p>
<p>X,Y, and Z axes are colored Red,Green, and Blue</p>
<p>Optional paremeters: 
<span class="param">duration</span>, and 
<span class="param">depthEnabled</span></p>
<pre class="source">
void addAxes(Matrix4 xform, num size,
            {num duration: 0.0, bool depthEnabled: true}) {
 var lineManager = depthEnabled ? _depthEnabledLines : _depthDisabledLines;

 Vector4 origin = new Vector4(0.0, 0.0, 0.0, 1.0);
 num size_90p = 0.9 * size;
 num size_10p = 0.1 * size;

 Vector4 color;

 Vector4 X = new Vector4(size, 0.0, 0.0, 1.0);
 Vector4 X_head_0 = new Vector4(size_90p, size_10p, 0.0, 1.0);
 Vector4 X_head_1 = new Vector4(size_90p, -size_10p, 0.0, 1.0);
 Vector4 X_head_2 = new Vector4(size_90p, 0.0, size_10p, 1.0);
 Vector4 X_head_3 = new Vector4(size_90p, 0.0, -size_10p, 1.0);

 Vector4 Y = new Vector4(0.0, size, 0.0, 1.0);
 Vector4 Y_head_0 = new Vector4(size_10p, size_90p, 0.0, 1.0);
 Vector4 Y_head_1 = new Vector4(-size_10p, size_90p, 0.0, 1.0);
 Vector4 Y_head_2 = new Vector4(0.0, size_90p, size_10p, 1.0);
 Vector4 Y_head_3 = new Vector4(0.0, size_90p, -size_10p, 1.0);


 Vector4 Z = new Vector4(0.0, 0.0, size, 1.0);
 Vector4 Z_head_0 = new Vector4(size_10p, 0.0, size_90p, 1.0);
 Vector4 Z_head_1 = new Vector4(-size_10p, 0.0, size_90p, 1.0);
 Vector4 Z_head_2 = new Vector4(0.0, size_10p, size_90p, 1.0);
 Vector4 Z_head_3 = new Vector4(0.0, -size_10p, size_90p, 1.0);

 origin = xform * origin;

 X = xform * X;
 X_head_0 = xform * X_head_0;
 X_head_1 = xform * X_head_1;
 X_head_2 = xform * X_head_2;
 X_head_3 = xform * X_head_3;

 color = new Vector4(1.0, 0.0, 0.0, 1.0);
 lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
     duration);
 lineManager.lines._addLine(origin.xyz, X.xyz);
 lineManager.lines._addLine(X.xyz, X_head_0.xyz);
 lineManager.lines._addLine(X.xyz, X_head_1.xyz);
 lineManager.lines._addLine(X.xyz, X_head_2.xyz);
 lineManager.lines._addLine(X.xyz, X_head_3.xyz);
 lineManager.lines.finishLineObject();

 Y = xform * Y;
 Y_head_0 = xform * Y_head_0;
 Y_head_1 = xform * Y_head_1;
 Y_head_2 = xform * Y_head_2;
 Y_head_3 = xform * Y_head_3;

 color = new Vector4(0.0, 1.0, 0.0, 1.0);
 lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
     duration);
 lineManager.lines._addLine(origin.xyz, Y.xyz);
 lineManager.lines._addLine(Y.xyz, Y_head_0.xyz);
 lineManager.lines._addLine(Y.xyz, Y_head_1.xyz);
 lineManager.lines._addLine(Y.xyz, Y_head_2.xyz);
 lineManager.lines._addLine(Y.xyz, Y_head_3.xyz);
 lineManager.lines.finishLineObject();

 Z = xform * Z;
 Z_head_0 = xform * Z_head_0;
 Z_head_1 = xform * Z_head_1;
 Z_head_2 = xform * Z_head_2;
 Z_head_3 = xform * Z_head_3;

 color = new Vector4(0.0, 0.0, 1.0, 1.0);
 lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
     duration);
 lineManager.lines._addLine(origin.xyz, Z.xyz);
 lineManager.lines._addLine(Z.xyz, Z_head_0.xyz);
 lineManager.lines._addLine(Z.xyz, Z_head_1.xyz);
 lineManager.lines._addLine(Z.xyz, Z_head_2.xyz);
 lineManager.lines._addLine(Z.xyz, Z_head_3.xyz);
 lineManager.lines.finishLineObject();
}
</pre>
</div>
</div>
<div class="method"><h4 id="addCircle">
<button class="show-code">Code</button>
void <strong>addCircle</strong>(<a href="../vector_math/Vector3.html">Vector3</a> center, <a href="../vector_math/Vector3.html">Vector3</a> planeNormal, num radius, <a href="../vector_math/Vector4.html">Vector4</a> color, {num duration: 0.0, bool depthEnabled: true, int numSegments: 16}) <a class="anchor-link" href="#addCircle"
              title="Permalink to DebugDrawManager.addCircle">#</a></h4>
<div class="doc">
<p>Add an circle primitive at 
<span class="param">center</span> in the plane whose normal is

<span class="param">planeNormal</span> with a 
<span class="param">radius</span>. Filled with 
<span class="param">color</span>.</p>
<p>Optional parameters: 
<span class="param">duration</span>, 
<span class="param">depthEnabled</span>, and 
<span class="param">numSegments</span>.</p>
<pre class="source">
void addCircle(Vector3 center, Vector3 planeNormal, num radius, Vector4 color,
              {num duration: 0.0, bool depthEnabled: true,
              int numSegments: 16}) {
 var lineManager = depthEnabled ? _depthEnabledLines : _depthDisabledLines;
 lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
                                   duration);

 buildPlaneVectors(planeNormal, _circle_u, _circle_v);
 num alpha = 0.0;
 num twoPi = (2.0 * 3.141592653589793238462643);
 num _step = twoPi/numSegments;

 double lastX = center.x + _circle_u.x * radius;
 double lastY = center.y + _circle_u.y * radius;
 double lastZ = center.z + _circle_u.z * radius;

 for (alpha = 0.0; alpha &lt;= twoPi; alpha += _step) {
   double cosScale = Math.cos(alpha) * radius;
   double sinScale = Math.sin(alpha) * radius;
   double pX = center.x + cosScale * _circle_u.x + sinScale * _circle_v.x;
   double pY = center.y + cosScale * _circle_u.y + sinScale * _circle_v.y;
   double pZ = center.z + cosScale * _circle_u.z + sinScale * _circle_v.z;
   lineManager.lines._addLineRaw(lastX, lastY, lastZ, pX, pY, pZ);
   lastX = pX;
   lastY = pY;
   lastZ = pZ;
 }
 lineManager.lines._addLineRaw(lastX, lastY, lastZ,
                               center.x + _circle_u.x * radius,
                               center.y + _circle_u.y * radius,
                               center.z + _circle_u.z * radius);
 lineManager.lines.finishLineObject();
}
</pre>
</div>
</div>
<div class="method"><h4 id="addCross">
<button class="show-code">Code</button>
void <strong>addCross</strong>(<a href="../vector_math/Vector3.html">Vector3</a> point, <a href="../vector_math/Vector4.html">Vector4</a> color, {num size: 1.0, num duration: 0.0, bool depthEnabled: true}) <a class="anchor-link" href="#addCross"
              title="Permalink to DebugDrawManager.addCross">#</a></h4>
<div class="doc">
<p>Add a cross primitive at 
<span class="param">point</span>. Filled with 
<span class="param">color</span>.</p>
<p>Optional paremeters: 
<span class="param">size</span>, 
<span class="param">duration</span>, and 
<span class="param">depthEnabled</span>.</p>
<pre class="source">
void addCross(Vector3 point, Vector4 color,
             {num size: 1.0, num duration: 0.0, bool depthEnabled:true}) {
 var lineManager = depthEnabled ? _depthEnabledLines : _depthDisabledLines;
 lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
                                   duration);
 num half_size = size * 0.5;
 lineManager.lines._addLine(point, point + new Vector3(half_size, 0.0, 0.0));
 lineManager.lines._addLine(point, point + new Vector3(-half_size, 0.0, 0.0));
 lineManager.lines._addLine(point, point + new Vector3(0.0, half_size, 0.0));
 lineManager.lines._addLine(point, point + new Vector3(0.0, -half_size, 0.0));
 lineManager.lines._addLine(point, point + new Vector3(0.0, 0.0, half_size));
 lineManager.lines._addLine(point, point + new Vector3(0.0, 0.0, -half_size));
 lineManager.lines.finishLineObject();
}
</pre>
</div>
</div>
<div class="method"><h4 id="addLine">
<button class="show-code">Code</button>
void <strong>addLine</strong>(<a href="../vector_math/Vector3.html">Vector3</a> start, <a href="../vector_math/Vector3.html">Vector3</a> finish, <a href="../vector_math/Vector4.html">Vector4</a> color, {num duration: 0.0, bool depthEnabled: true}) <a class="anchor-link" href="#addLine"
              title="Permalink to DebugDrawManager.addLine">#</a></h4>
<div class="doc">
<p>Add a line primitive extending from 
<span class="param">start</span> to 
<span class="param">finish</span>.
Filled with 
<span class="param">color</span>.</p>
<p>Optional parameters: 
<span class="param">duration</span> and 
<span class="param">depthEnabled</span>.</p>
<pre class="source">
void addLine(Vector3 start, Vector3 finish, Vector4 color,
            {num duration: 0.0, bool depthEnabled: true}) {
 var lineManager = depthEnabled ? _depthEnabledLines : _depthDisabledLines;
 lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
                                   duration);
 lineManager.lines._addLine(start, finish);
 lineManager.lines.finishLineObject();
}
</pre>
</div>
</div>
<div class="method"><h4 id="addSphere">
<button class="show-code">Code</button>
void <strong>addSphere</strong>(<a href="../vector_math/Vector3.html">Vector3</a> center, num radius, <a href="../vector_math/Vector4.html">Vector4</a> color, {num duration: 0.0, bool depthEnabled: true}) <a class="anchor-link" href="#addSphere"
              title="Permalink to DebugDrawManager.addSphere">#</a></h4>
<div class="doc">
<p>Add a sphere primitive at 
<span class="param">center</span> with 
<span class="param">radius</span>. Filled with 
<span class="param">color</span>.</p>
<p>Optional paremeters: 
<span class="param">duration</span> and 
<span class="param">depthEnabled</span>.</p>
<pre class="source">
void addSphere(Vector3 center, num radius, Vector4 color,
              {num duration: 0.0, bool depthEnabled: true}) {
 var lineManager = depthEnabled ? _depthEnabledLines : _depthDisabledLines;
 lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
                                   duration);

 int latSegments = 6;
 int lonSegments = 8;
 num twoPi = (2.0 * Math.PI);

 Vector3 lastVertex, vertex, upperVertex;

 for (int y = 0; y &lt; latSegments; ++y) {
   lastVertex = null;
   for (int x = 0; x &lt;= lonSegments; ++x) {
     num u = x / lonSegments;
     num v = y / latSegments;
     num v2 = (y+1) / latSegments;

     vertex = new Vector3(
         radius * Math.cos(u * twoPi) * Math.sin(v * Math.PI),
         radius * Math.cos(v * Math.PI),
         radius * Math.sin(u * twoPi) * Math.sin(v * Math.PI)
     ) + center;

     upperVertex = new Vector3(
         radius * Math.cos(u * twoPi) * Math.sin(v2 * Math.PI),
         radius * Math.cos(v2 * Math.PI),
         radius * Math.sin(u * twoPi) * Math.sin(v2 * Math.PI)
     ) + center;

     if(lastVertex != null) {
       lineManager.lines._addLineRaw(
           lastVertex.x, lastVertex.y, lastVertex.z,
           vertex.x, vertex.y, vertex.z);
       lineManager.lines._addLineRaw(
           upperVertex.x, upperVertex.y, upperVertex.z,
           vertex.x, vertex.y, vertex.z);
     }

     lastVertex = vertex;
   }
 }
 lineManager.lines.finishLineObject();
}
</pre>
</div>
</div>
<div class="method"><h4 id="addTriangle">
<button class="show-code">Code</button>
void <strong>addTriangle</strong>(<a href="../vector_math/Vector3.html">Vector3</a> vertex0, <a href="../vector_math/Vector3.html">Vector3</a> vertex1, <a href="../vector_math/Vector3.html">Vector3</a> vertex2, <a href="../vector_math/Vector4.html">Vector4</a> color, {num duration: 0.0, bool depthEnabled: true}) <a class="anchor-link" href="#addTriangle"
              title="Permalink to DebugDrawManager.addTriangle">#</a></h4>
<div class="doc">
<p>Add a triangle primitives from vertices 
<span class="param">vertex0</span>, 
<span class="param">vertex1</span>,
and 
<span class="param">vertex2</span>. Filled with 
<span class="param">color</span>.</p>
<p>Optional parameters: 
<span class="param">duration</span> and 
<span class="param">depthEnabled</span></p>
<pre class="source">
void addTriangle(Vector3 vertex0, Vector3 vertex1, Vector3 vertex2, Vector4 color,
                {num duration: 0.0, bool depthEnabled: true}) {
 var lineManager = depthEnabled ? _depthEnabledLines : _depthDisabledLines;
 lineManager.lines.startLineObject(color.r, color.g, color.b, color.a,
                                   duration);
 lineManager.lines._addLine(vertex0, vertex1);
 lineManager.lines._addLine(vertex1, vertex2);
 lineManager.lines._addLine(vertex2, vertex0);
 lineManager.lines.finishLineObject();
}
</pre>
</div>
</div>
<div class="method"><h4 id="prepareForRender">
<button class="show-code">Code</button>
void <strong>prepareForRender</strong>() <a class="anchor-link" href="#prepareForRender"
              title="Permalink to DebugDrawManager.prepareForRender">#</a></h4>
<div class="doc">
<p>Prepare to render debug primitives</p>
<pre class="source">
void prepareForRender() {
 _depthEnabledLines._prepareForRender(device.context);
 _depthDisabledLines._prepareForRender(device.context);
}
</pre>
</div>
</div>
<div class="method"><h4 id="render">
<button class="show-code">Code</button>
void <strong>render</strong>(<a href="../spectre/Camera.html">Camera</a> cam) <a class="anchor-link" href="#render"
              title="Permalink to DebugDrawManager.render">#</a></h4>
<div class="doc">
<p>Render debug primitives for [Camera] [cam]</p>
<pre class="source">
void render(Camera cam) {
 Matrix4 pm = cam.projectionMatrix;
 Matrix4 la = cam.viewMatrix;
 pm.multiply(la);
 pm.copyIntoArray(_cameraMatrix);
 device.context.setShaderProgram(_lineShaderProgram);
 device.context.setConstant('cameraTransform', _cameraMatrix);
 _depthState.depthBufferEnabled = true;
 _depthState.depthBufferWriteEnabled = true;
 device.context.setDepthState(_depthState);
 device.context.setBlendState(_blendState);
 device.context.setRasterizerState(_rasterizerState);
 device.context.setInputLayout(_depthEnabledLines._lineMeshInputLayout);
 device.context.setMesh(_depthEnabledLines._lineMesh);
 device.context.drawMesh(_depthEnabledLines._lineMesh);
 _depthState.depthBufferEnabled = false;
 _depthState.depthBufferWriteEnabled = false;
 device.context.setDepthState(_depthState);
 device.context.setMesh(_depthDisabledLines._lineMesh);
 device.context.drawMesh(_depthDisabledLines._lineMesh);
}
</pre>
</div>
</div>
<div class="method"><h4 id="update">
<button class="show-code">Code</button>
void <strong>update</strong>(num seconds) <a class="anchor-link" href="#update"
              title="Permalink to DebugDrawManager.update">#</a></h4>
<div class="doc">
<p>Update time 
<span class="param">seconds</span>, removing any dead debug primitives</p>
<pre class="source">
void update(num seconds) {
 _depthEnabledLines.update(seconds);
 _depthDisabledLines.update(seconds);
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-06-13 15:38:32.888</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
