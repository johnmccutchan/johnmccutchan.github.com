        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>DdsPixelFormat class / spectre_asset_pack Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="spectre_asset_pack" data-type="DdsPixelFormat">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../spectre_asset_pack.html">spectre_asset_pack</a> &rsaquo; <a href="../spectre_asset_pack/DdsPixelFormat.html">DdsPixelFormat</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>DdsPixelFormat</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>The surface pixel format.</p>
<p>Accessors correspond to the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb943984">DDS_PIXELFORMAT</a>
structure.</p>
<pre class="source">
class DdsPixelFormat {
 //---------------------------------------------------------------------
 // Class variables
 //---------------------------------------------------------------------

 /// The offset in bytes to the DDS_PIXELFORMAT struct within the file.
 ///
 /// The DDS_PIXEL_FORMAT is within the boundary of DDS_HEADER.
 static const int _byteOffset = DdsHeader._byteOffset + 72;
 /// The size of the DDS_PIXELFORMAT struct.
 static const int _structSize = 32;

 //---------------------------------------------------------------------
 // Flags
 //---------------------------------------------------------------------

 /// Texture contains alpha data
 static const int _hasAlphaData = 0x1;
 /// Texture contains alpha data (legacy).
 static const int _hasAlphaDataLegacy = 0x2;
 /// Texture contains compressed data, floating point data, or some exotic format.
 ///
 /// If the flag is present the value in [characterCode] is valid.
 static const int _hasCharacterCode = 0x4;
 /// Texture contains uncompressed RGB data.
 ///
 /// The values in bitCount and the RGB masks [redBitMask], [greenBitMask], [blueBitMask] contain valid data.
 static const int _hasRgbValues = 0x40;
 /// Texture contains YUV compressed data.
 ///
 /// The value in bitCount contains the YUV bit count. The Y mask is within [redBitMask]. The U mask is
 /// within [greenBitMask]. The V mask is within [blueBitMask].
 static const int _hasYuvValues = 0x200;
 /// Texture contains luminance data or some other single channel color.
 ///
 /// The value in bitCount contains the luminance channel bit count. The channel mask is contained in
 /// [redBitMask]. It can be combined with _hasAlphaData for a two channel DDS file.
 static const int _hasLuminanceValues = 0x20000;
 /// Texture contains uncompressed RGBA data.
 ///
 /// The values in bitCount and the RGB masks [redBitMask], [greenBitMask], [blueBitMask], and [alphaBitMask]
 /// contain valid data.
 static const int _hasRgbaValues = _hasAlphaData | _hasRgbValues;
 /// Texture contains two channels.
 static const int _hasTwoChannels = _hasAlphaData | _hasLuminanceValues;

 //---------------------------------------------------------------------
 // Character codes
 //---------------------------------------------------------------------

 /// The DXT1 character code, 'DXT1'.
 static const int _dxt1CharacterCode = 827611204;
 /// The DXT2 character code, 'DXT2'.
 static const int _dxt2CharacterCode = 844388420;
 /// The DXT3 character code, 'DXT3'.
 static const int _dxt3CharacterCode = 861165636;
 /// The DXT4 character code, 'DXT4'.
 static const int _dxt4CharacterCode = 877942852;
 /// The DXT5 character code, 'DXT5'.
 static const int _dxt5CharacterCode = 894720068;
 /// The BC4U character code, 'BC4U'.
 static const int _bc4uCharacterCode = 1429488450;
 /// The BC4S character code, 'BC4S'.
 static const int _bc4sCharacterCode = 1395934018;
 /// The ATI2 character code, 'ATI2'.
 static const int _ati2CharacterCode = 843666497;
 /// The BC5U character code, 'BC5U'.
 static const int _bc5uCharacterCode = 1429553986;
 /// The BC5S character code, 'BC5S'.
 static const int _bc5sCharacterCode = 1395999554;
 /// The RGBG character code, 'RGBG'.
 static const int _rgbgCharacterCode = 1195525970;
 /// The GRGB character code, 'GRGB'.
 static const int _grbgCharacterCode = 1111970375;
 /// The UYVY character code, 'UYVY'.
 static const int _uyvyCharacterCode = 1498831189;
 /// The YUY2 character code, 'YUY2'.
 static const int _yuy2CharacterCode = 844715353;
 /// 64-bit RGBA unsigned-normalized-integer character code.
 static const int _unormR16G16B16A16CharacterCode = 36;
 /// 64-bit RGBA signed-normalized-integer character code.
 static const int _normR16G16B16A16CharacterCode = 110;
 /// 16-bit R floating point character code.
 static const int _floatR16CharacterCode = 111;
 /// 32-bit RG floating point character code.
 static const int _floatR16G16CharacterCode = 112;
 /// 64-bit RGBA floating point character code.
 static const int _floatR16G16B16A16CharacterCode = 113;
 /// 32-bit R floating point character code.
 static const int _floatR32CharacterCode = 114;
 /// 64-bit RG floating point character code.
 static const int _floatR32G32CharacterCode = 115;
 /// 128-bit RGBA floating point character code.
 static const int _floatR32G32B32A32CharacterCode = 116;
 /// The DX10 character code, 'DX10'.
 ///
 /// Means that the extended header DX10 is present.
 static const int _dx10CharacterCode = 808540228;

 //---------------------------------------------------------------------
 // Member variables
 //---------------------------------------------------------------------

 /// The size of the structure
 int _size;
 /// Flags to indicate what type of data is in the surface.
 int _flags;
 /// Character code for specifying compressed or custom format.
 int _characterCode;
 /// Number of bits in an RGB (possibly including alpha) format.
 int _rgbBitCount;
 /// Red (or lumiannce or Y) mask for reading color data.
 int _redBitMask;
 /// Green (or U) mask for reading color data.
 int _greenBitMask;
 /// Blue (or V) mask for reading color data.
 int _blueBitMask;
 /// Alpha mask for reading alpha data.
 int _alphaBitMask;

 //---------------------------------------------------------------------
 // Constructor
 //---------------------------------------------------------------------

 /// Creates an instance of the [DdsPixelFormat] class.
 DdsPixelFormat._internal(Uint8List buffer) {
   Uint32List reader = new Uint32List.view(buffer, _byteOffset);

   _size          = reader[0];
   _flags         = reader[1];
   _characterCode = reader[2];
   _rgbBitCount   = reader[3];
   _redBitMask    = reader[4];
   _greenBitMask  = reader[5];
   _blueBitMask   = reader[6];
   _alphaBitMask  = reader[7];
 }

 //---------------------------------------------------------------------
 // Properties
 //---------------------------------------------------------------------

 /// The size of the structure
 int get size =&gt; _size;
 /// Flags to indicate what type of data is in the surface.
 int get flags =&gt; _flags;
 /// Character code for specifying compressed or custom format.
 int get characterCode =&gt; _characterCode;
 /// Number of bits in an RGB (possibly including alpha) format.
 int get rgbBitCount =&gt; _rgbBitCount;
 /// Red (or lumiannce or Y) mask for reading color data.
 int get redBitMask =&gt; _redBitMask;
 /// Green (or U) mask for reading color data.
 int get greenBitMask =&gt; _greenBitMask;
 /// Blue (or V) mask for reading color data.
 int get blueBitMask =&gt; _blueBitMask;
 /// Alpha mask for reading alpha data.
 int get alphaBitMask =&gt; _alphaBitMask;

 /// Gets the resource format.
 ///
 /// If the [DdsExtendedHeader] is present then this value should be ignored.
 int get resourceFormat {
   // Check for types encoded in a character code
   //
   // Some of these formats should be in the extended header but not all DDS
   // writers, including Microsoft's DirectX Texture Tool, use the extended header.
   if ((_flags &amp; _hasCharacterCode) == _hasCharacterCode) {
     switch (_characterCode) {
       case _dxt1CharacterCode             : return DdsResourceFormat.UnormBc1;
       case _dxt2CharacterCode             : return DdsResourceFormat.Unknown;
       case _dxt3CharacterCode             : return DdsResourceFormat.UnormBc2;
       case _dxt4CharacterCode             : return DdsResourceFormat.Unknown;
       case _dxt5CharacterCode             : return DdsResourceFormat.UnormBc3;
       case _bc4uCharacterCode             : return DdsResourceFormat.UnormBc4;
       case _bc4sCharacterCode             : return DdsResourceFormat.NormBc4;
       case _ati2CharacterCode             : return DdsResourceFormat.UnormBc4;
       case _bc5uCharacterCode             : return DdsResourceFormat.UnormBc5;
       case _bc5sCharacterCode             : return DdsResourceFormat.NormBc5;
       case _rgbgCharacterCode             : return DdsResourceFormat.UnormR8G8B8G8;
       case _grbgCharacterCode             : return DdsResourceFormat.UnormG8R8G8B8;
       case _uyvyCharacterCode             : return DdsResourceFormat.Unknown;
       case _yuy2CharacterCode             : return DdsResourceFormat.Unknown;
       case _unormR16G16B16A16CharacterCode: return DdsResourceFormat.UnormR16G16B16A16;
       case _normR16G16B16A16CharacterCode : return DdsResourceFormat.NormR16G16B16A16;
       case _floatR16CharacterCode         : return DdsResourceFormat.FloatR16;
       case _floatR16G16CharacterCode      : return DdsResourceFormat.FloatR16G16;
       case _floatR16G16B16A16CharacterCode: return DdsResourceFormat.FloatR16G16B16A16;
       case _floatR32CharacterCode         : return DdsResourceFormat.FloatR32;
       case _floatR32G32CharacterCode      : return DdsResourceFormat.FloatR32G32;
       case _floatR32G32B32A32CharacterCode: return DdsResourceFormat.FloatR32G32B32A32;
       case _dx10CharacterCode             : return DdsResourceFormat.Unknown;
     }
   }

   // Check for RGB formats
   if (_rgbBitCount == 32) {
     if ((_flags &amp; _hasRgbaValues) == _hasRgbaValues) {
       if ((_redBitMask == 0x000000ff) &amp;&amp; (_greenBitMask == 0x0000ff00) &amp;&amp; (_blueBitMask == 0x00ff0000) &amp;&amp; (_alphaBitMask == 0xff000000)) {
         return DdsResourceFormat.UnormR8G8B8A8;
       } else if ((_redBitMask == 0x00ff0000) &amp;&amp; (_greenBitMask == 0x0000ff00) &amp;&amp; (_blueBitMask == 0x000000ff) &amp;&amp; (_alphaBitMask == 0xff000000)) {
         return DdsResourceFormat.UnormB8G8R8A8;
       } else if ((_redBitMask == 0x0000ffff) &amp;&amp; (_greenBitMask == 0xffff0000)) {
         // This is in the documentation but isn't an actual RGBA format
         return DdsResourceFormat.UnormR16G16;
       } else if ((_redBitMask == 0x3ff00000) &amp;&amp; (_greenBitMask == 0x000ffc00) &amp;&amp; (_blueBitMask == 0x000003ff) &amp;&amp; (_alphaBitMask == 0x00c00000)) {
         return DdsResourceFormat.UnormR10G10B10A2;
       }
     } else if ((_flags &amp; _hasRgbValues) == _hasRgbValues) {
       if ((_redBitMask == 0x0000ffff) &amp;&amp; (_greenBitMask == 0xffff0000)) {
         return DdsResourceFormat.UnormR16G16;
       } else if ((_redBitMask == 0x00ff0000) &amp;&amp; (_greenBitMask == 0x0000ff00) &amp;&amp; (_blueBitMask == 0x000000ff)) {
         return DdsResourceFormat.UnormB8G8R8X8;
       }
     }
   } else if (_rgbBitCount == 16) {
     if ((flags &amp; _hasRgbaValues) == _hasRgbaValues) {
       if ((_redBitMask == 0x7c00) &amp;&amp; (_greenBitMask == 0x03e0) &amp;&amp; (_blueBitMask == 0x001f) &amp;&amp; (_alphaBitMask == 0x8000)) {
         return DdsResourceFormat.UnormB5G5R5A1;
       }
     } else if ((_flags &amp; _hasRgbValues) == _hasRgbValues) {
       if ((_redBitMask == 0xf800) &amp;&amp; (_greenBitMask == 0x07e0) &amp;&amp; (_blueBitMask == 0x001f)) {
         return DdsResourceFormat.UnormB5G6R5;
       }
     } else if ((_flags &amp; _hasTwoChannels) == _hasTwoChannels) {
       if ((_redBitMask == 0x00ff) &amp;&amp; (_alphaBitMask == 0xff00)) {
         return DdsResourceFormat.UnormR8G8;
       }
     } else if ((_flags &amp; _hasLuminanceValues) == _hasLuminanceValues) {
       if (_redBitMask == 0xffff) {
         return DdsResourceFormat.UnormR16;
       }
     }
   } else if (_rgbBitCount == 8) {
     if ((_flags &amp; _hasLuminanceValues) == _hasLuminanceValues) {
       if (_redBitMask == 0xff) {
         return DdsResourceFormat.UnormR8;
       }
     } else if (((_flags &amp; _hasAlphaData) == _hasAlphaData) || ((_flags &amp; _hasAlphaDataLegacy) == _hasAlphaDataLegacy)) {
       if (_alphaBitMask == 0xff) {
         return DdsResourceFormat.UnormA8;
       }
     }
   }

   // Unknown format
   return DdsResourceFormat.Unknown;
 }
}
</pre>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="alphaBitMask">
<button class="show-code">Code</button>
final int         <strong>alphaBitMask</strong> <a class="anchor-link"
            href="#alphaBitMask"
            title="Permalink to DdsPixelFormat.alphaBitMask">#</a>
        </h4>
        <div class="doc">
<p>Alpha mask for reading alpha data.</p>
<pre class="source">
int get alphaBitMask =&gt; _alphaBitMask;
</pre>
</div>
</div>
<div class="field"><h4 id="blueBitMask">
<button class="show-code">Code</button>
final int         <strong>blueBitMask</strong> <a class="anchor-link"
            href="#blueBitMask"
            title="Permalink to DdsPixelFormat.blueBitMask">#</a>
        </h4>
        <div class="doc">
<p>Blue (or V) mask for reading color data.</p>
<pre class="source">
int get blueBitMask =&gt; _blueBitMask;
</pre>
</div>
</div>
<div class="field"><h4 id="characterCode">
<button class="show-code">Code</button>
final int         <strong>characterCode</strong> <a class="anchor-link"
            href="#characterCode"
            title="Permalink to DdsPixelFormat.characterCode">#</a>
        </h4>
        <div class="doc">
<p>Character code for specifying compressed or custom format.</p>
<pre class="source">
int get characterCode =&gt; _characterCode;
</pre>
</div>
</div>
<div class="field"><h4 id="flags">
<button class="show-code">Code</button>
final int         <strong>flags</strong> <a class="anchor-link"
            href="#flags"
            title="Permalink to DdsPixelFormat.flags">#</a>
        </h4>
        <div class="doc">
<p>Flags to indicate what type of data is in the surface.</p>
<pre class="source">
int get flags =&gt; _flags;
</pre>
</div>
</div>
<div class="field"><h4 id="greenBitMask">
<button class="show-code">Code</button>
final int         <strong>greenBitMask</strong> <a class="anchor-link"
            href="#greenBitMask"
            title="Permalink to DdsPixelFormat.greenBitMask">#</a>
        </h4>
        <div class="doc">
<p>Green (or U) mask for reading color data.</p>
<pre class="source">
int get greenBitMask =&gt; _greenBitMask;
</pre>
</div>
</div>
<div class="field"><h4 id="redBitMask">
<button class="show-code">Code</button>
final int         <strong>redBitMask</strong> <a class="anchor-link"
            href="#redBitMask"
            title="Permalink to DdsPixelFormat.redBitMask">#</a>
        </h4>
        <div class="doc">
<p>Red (or lumiannce or Y) mask for reading color data.</p>
<pre class="source">
int get redBitMask =&gt; _redBitMask;
</pre>
</div>
</div>
<div class="field"><h4 id="resourceFormat">
<button class="show-code">Code</button>
final int         <strong>resourceFormat</strong> <a class="anchor-link"
            href="#resourceFormat"
            title="Permalink to DdsPixelFormat.resourceFormat">#</a>
        </h4>
        <div class="doc">
<p>Gets the resource format.</p>
<p>If the <a class="crossref" href="../spectre_asset_pack/DdsExtendedHeader.html">DdsExtendedHeader</a> is present then this value should be ignored.</p>
<pre class="source">
int get resourceFormat {
 // Check for types encoded in a character code
 //
 // Some of these formats should be in the extended header but not all DDS
 // writers, including Microsoft's DirectX Texture Tool, use the extended header.
 if ((_flags &amp; _hasCharacterCode) == _hasCharacterCode) {
   switch (_characterCode) {
     case _dxt1CharacterCode             : return DdsResourceFormat.UnormBc1;
     case _dxt2CharacterCode             : return DdsResourceFormat.Unknown;
     case _dxt3CharacterCode             : return DdsResourceFormat.UnormBc2;
     case _dxt4CharacterCode             : return DdsResourceFormat.Unknown;
     case _dxt5CharacterCode             : return DdsResourceFormat.UnormBc3;
     case _bc4uCharacterCode             : return DdsResourceFormat.UnormBc4;
     case _bc4sCharacterCode             : return DdsResourceFormat.NormBc4;
     case _ati2CharacterCode             : return DdsResourceFormat.UnormBc4;
     case _bc5uCharacterCode             : return DdsResourceFormat.UnormBc5;
     case _bc5sCharacterCode             : return DdsResourceFormat.NormBc5;
     case _rgbgCharacterCode             : return DdsResourceFormat.UnormR8G8B8G8;
     case _grbgCharacterCode             : return DdsResourceFormat.UnormG8R8G8B8;
     case _uyvyCharacterCode             : return DdsResourceFormat.Unknown;
     case _yuy2CharacterCode             : return DdsResourceFormat.Unknown;
     case _unormR16G16B16A16CharacterCode: return DdsResourceFormat.UnormR16G16B16A16;
     case _normR16G16B16A16CharacterCode : return DdsResourceFormat.NormR16G16B16A16;
     case _floatR16CharacterCode         : return DdsResourceFormat.FloatR16;
     case _floatR16G16CharacterCode      : return DdsResourceFormat.FloatR16G16;
     case _floatR16G16B16A16CharacterCode: return DdsResourceFormat.FloatR16G16B16A16;
     case _floatR32CharacterCode         : return DdsResourceFormat.FloatR32;
     case _floatR32G32CharacterCode      : return DdsResourceFormat.FloatR32G32;
     case _floatR32G32B32A32CharacterCode: return DdsResourceFormat.FloatR32G32B32A32;
     case _dx10CharacterCode             : return DdsResourceFormat.Unknown;
   }
 }

 // Check for RGB formats
 if (_rgbBitCount == 32) {
   if ((_flags &amp; _hasRgbaValues) == _hasRgbaValues) {
     if ((_redBitMask == 0x000000ff) &amp;&amp; (_greenBitMask == 0x0000ff00) &amp;&amp; (_blueBitMask == 0x00ff0000) &amp;&amp; (_alphaBitMask == 0xff000000)) {
       return DdsResourceFormat.UnormR8G8B8A8;
     } else if ((_redBitMask == 0x00ff0000) &amp;&amp; (_greenBitMask == 0x0000ff00) &amp;&amp; (_blueBitMask == 0x000000ff) &amp;&amp; (_alphaBitMask == 0xff000000)) {
       return DdsResourceFormat.UnormB8G8R8A8;
     } else if ((_redBitMask == 0x0000ffff) &amp;&amp; (_greenBitMask == 0xffff0000)) {
       // This is in the documentation but isn't an actual RGBA format
       return DdsResourceFormat.UnormR16G16;
     } else if ((_redBitMask == 0x3ff00000) &amp;&amp; (_greenBitMask == 0x000ffc00) &amp;&amp; (_blueBitMask == 0x000003ff) &amp;&amp; (_alphaBitMask == 0x00c00000)) {
       return DdsResourceFormat.UnormR10G10B10A2;
     }
   } else if ((_flags &amp; _hasRgbValues) == _hasRgbValues) {
     if ((_redBitMask == 0x0000ffff) &amp;&amp; (_greenBitMask == 0xffff0000)) {
       return DdsResourceFormat.UnormR16G16;
     } else if ((_redBitMask == 0x00ff0000) &amp;&amp; (_greenBitMask == 0x0000ff00) &amp;&amp; (_blueBitMask == 0x000000ff)) {
       return DdsResourceFormat.UnormB8G8R8X8;
     }
   }
 } else if (_rgbBitCount == 16) {
   if ((flags &amp; _hasRgbaValues) == _hasRgbaValues) {
     if ((_redBitMask == 0x7c00) &amp;&amp; (_greenBitMask == 0x03e0) &amp;&amp; (_blueBitMask == 0x001f) &amp;&amp; (_alphaBitMask == 0x8000)) {
       return DdsResourceFormat.UnormB5G5R5A1;
     }
   } else if ((_flags &amp; _hasRgbValues) == _hasRgbValues) {
     if ((_redBitMask == 0xf800) &amp;&amp; (_greenBitMask == 0x07e0) &amp;&amp; (_blueBitMask == 0x001f)) {
       return DdsResourceFormat.UnormB5G6R5;
     }
   } else if ((_flags &amp; _hasTwoChannels) == _hasTwoChannels) {
     if ((_redBitMask == 0x00ff) &amp;&amp; (_alphaBitMask == 0xff00)) {
       return DdsResourceFormat.UnormR8G8;
     }
   } else if ((_flags &amp; _hasLuminanceValues) == _hasLuminanceValues) {
     if (_redBitMask == 0xffff) {
       return DdsResourceFormat.UnormR16;
     }
   }
 } else if (_rgbBitCount == 8) {
   if ((_flags &amp; _hasLuminanceValues) == _hasLuminanceValues) {
     if (_redBitMask == 0xff) {
       return DdsResourceFormat.UnormR8;
     }
   } else if (((_flags &amp; _hasAlphaData) == _hasAlphaData) || ((_flags &amp; _hasAlphaDataLegacy) == _hasAlphaDataLegacy)) {
     if (_alphaBitMask == 0xff) {
       return DdsResourceFormat.UnormA8;
     }
   }
 }

 // Unknown format
 return DdsResourceFormat.Unknown;
}
</pre>
</div>
</div>
<div class="field"><h4 id="rgbBitCount">
<button class="show-code">Code</button>
final int         <strong>rgbBitCount</strong> <a class="anchor-link"
            href="#rgbBitCount"
            title="Permalink to DdsPixelFormat.rgbBitCount">#</a>
        </h4>
        <div class="doc">
<p>Number of bits in an RGB (possibly including alpha) format.</p>
<pre class="source">
int get rgbBitCount =&gt; _rgbBitCount;
</pre>
</div>
</div>
<div class="field"><h4 id="size">
<button class="show-code">Code</button>
final int         <strong>size</strong> <a class="anchor-link"
            href="#size"
            title="Permalink to DdsPixelFormat.size">#</a>
        </h4>
        <div class="doc">
<p>The size of the structure</p>
<pre class="source">
int get size =&gt; _size;
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-06-13 15:38:33.034</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
